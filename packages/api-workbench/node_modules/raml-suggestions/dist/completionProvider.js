"use strict";
/// <reference path="../typings/main.d.ts" />
var parserApi = require("raml-1-parser");
var def = parserApi.ds;
var search = parserApi.search;
var universeModule = parserApi.universes;
var universeHelpers = parserApi.universeHelpers;
var services = def;
var _ = require("underscore");
function suggest(request, provider) {
    return getSuggestions(request, provider);
}
exports.suggest = suggest;
function getSuggestions(request, provider, preParsedAst) {
    if (preParsedAst === void 0) { preParsedAst = undefined; }
    provider.currentRequest = request;
    try {
        if (provider.level > 100) {
            return;
        }
        provider.level++;
        var offset = request.position.getOffset();
        var text = request.content.getText();
        var kind = completionKind(request);
        var node = (preParsedAst ? preParsedAst : getAstNode(request, provider.contentProvider));
        var hlnode = node;
        if (kind === parserApi.search.LocationKind.DIRECTIVE_COMPLETION) {
            return [{ text: "include" }];
        }
        if (kind === parserApi.search.LocationKind.ANNOTATION_COMPLETION) {
            var declarations = parserApi.search.globalDeclarations(hlnode).filter(function (x) { return parserApi.universeHelpers.isAnnotationTypesProperty(x.property()); });
            return declarations.map(function (x) {
                return {
                    text: parserApi.search.qName(x, hlnode),
                    annotation: true
                };
            });
        }
        if (kind === parserApi.search.LocationKind.VERSION_COMPLETION) {
            return ramlVersionCompletion(request);
        }
        if (kind === parserApi.search.LocationKind.INCOMMENT) {
            return [];
        }
        if (node === null) {
            return [];
        }
        var hasNewLine = false;
        for (var position = offset - 1; position >= hlnode.lowLevel().start(); position--) {
            var ch = text[position];
            if (ch == '\r' || ch == '\n') {
                hasNewLine = true;
                break;
            }
        }
        var cmi = offset;
        for (var pm = offset - 1; pm >= 0; pm--) {
            var c = text[pm];
            if (c === ' ' || c === '\t') {
                cmi = pm;
                continue;
            }
            break;
        }
        var attr = _.find(hlnode.attrs(), function (x) { return x.lowLevel().start() < cmi && x.lowLevel().end() >= cmi && !x.property().getAdapter(parserApi.ds.RAMLPropertyService).isKey(); });
        if (!attr) {
            var p = _.find(hlnode.definition().allProperties(), function (p) { return p.canBeValue(); });
            if (!hasNewLine) {
                if (p && kind == parserApi.search.LocationKind.VALUE_COMPLETION &&
                    parserApi.universeHelpers.isTypeProperty(p)) {
                    if (hlnode.children().length == 1) {
                        attr = parserApi.stubs.createASTPropImpl(hlnode.lowLevel(), hlnode, p.range(), p);
                    }
                }
            }
            else {
                var cm = _.find(hlnode.lowLevel().children(), function (x) { return x.start() < offset && x.end() >= offset; });
                if (cm) {
                    var p = _.find(hlnode.definition().allProperties(), function (p) { return p.nameId() == cm.key(); });
                    if (p) {
                        var il = getIndent(cm.keyStart(), cm.unit().contents());
                        var il2 = getIndent(offset, cm.unit().contents());
                        if (il2.length > il.length + 1) {
                            var isValue = p.range().hasValueTypeInHierarchy();
                            if (isValue) {
                                attr = parserApi.stubs.createVirtualASTPropImpl(cm, hlnode, p.range(), p);
                            }
                            else {
                                if (cm.children().length > 0) {
                                    hlnode = parserApi.stubs.createVirtualNodeImpl(cm.children()[0], hlnode, p.range(), p);
                                }
                            }
                        }
                    }
                }
            }
        }
        if (kind == parserApi.search.LocationKind.PATH_COMPLETION) {
            return pathCompletion(request, provider.contentProvider, attr, hlnode, false);
        }
        if (attr && (kind === parserApi.search.LocationKind.KEY_COMPLETION || kind === parserApi.search.LocationKind.SEQUENCE_KEY_COPLETION)) {
            var txt = "";
            for (var position = offset - 1; position >= 0; position--) {
                var ch = text[position];
                if (ch == '\r' || ch == '\n') {
                    break;
                }
                txt = ch + txt;
            }
            txt = txt.trim();
            if (txt != attr.name()) {
                kind = parserApi.search.LocationKind.VALUE_COMPLETION;
            }
        }
        if (kind == parserApi.search.LocationKind.VALUE_COMPLETION) {
            var parentPropertyOfAttr = attr && attr.parent && attr.parent() && attr.parent().property && attr.parent().property();
            if (parentPropertyOfAttr && universeHelpers.isUsesProperty(parentPropertyOfAttr)) {
                return pathCompletion(request, provider.contentProvider, attr, hlnode, false);
            }
            var proposals = valueCompletion(node, attr, request, provider);
            if (!attr) {
                if (!proposals || proposals.length == 0) {
                    if (!hasNewLine) {
                        if (hlnode.definition().getAdapter(parserApi.ds.RAMLService).isUserDefined()) {
                            return propertyCompletion(hlnode, request, mv, defNode, hasNewLine /*we can get 'k' only if we are completing the start of node key*/);
                        }
                    }
                }
            }
            if (attr && attr.property() && (attr.property().getAdapter(parserApi.ds.RAMLPropertyService).isTypeExpr() ||
                attr.property().isAnnotation())) {
                if (!proposals) {
                    proposals = [];
                }
                proposals = proposals.filter(function (x) {
                    var proposalText = getProposalText(x);
                    if (proposalText === hlnode.name()) {
                        return false;
                    }
                    return true;
                });
                var pref = request.valuePrefix();
                var nmi = pref.lastIndexOf(".");
                if (nmi) {
                    pref = pref.substr(0, nmi + 1);
                }
                else {
                    pref = null;
                }
                if (pref) {
                    proposals = proposals.filter(function (x) { return getProposalText(x).indexOf(pref) == 0; });
                    proposals.forEach(function (x) { return updateProposalText(x, getProposalText(x).substring(pref.length)); });
                }
            }
            if (proposals) {
                if (text[offset - 1] == ':') {
                    proposals.forEach(function (x) {
                        if (x.extra) {
                            x.extra = " " + x.extra;
                        }
                        else {
                            x.extra = " ";
                        }
                    });
                }
                if (request.prefix().indexOf("[") != -1) {
                    request.setPrefix("");
                    proposals.forEach(function (x) {
                        x.text = ": [ " + x.displayText;
                    });
                }
                else if (isSquareBracketExpected(attr)) {
                    proposals = proposals.filter(function (proposed) { return !isSiblingExists(attr, proposed.displayText); });
                    var ending = "";
                    var initialPosition = offset;
                    for (var i = initialPosition; i < text.length && !/[\t\n\r]/.test(text[i]); i++) {
                        ending += text[i];
                        if (ending.replace(/\s/g, '') === ":") {
                            proposals.forEach(function (x) {
                                x.text = x.displayText;
                                x.snippet = null;
                                x.extra = null;
                            });
                            break;
                        }
                    }
                    var isOpenSquarePresent = false;
                    initialPosition = offset - 1;
                    for (var i = initialPosition; i >= 0 && !/[\t\n\r]/.test(text[i]); i--) {
                        if (text[i] === "[") {
                            isOpenSquarePresent = true;
                            break;
                        }
                    }
                    if (!isOpenSquarePresent) {
                        proposals.forEach(function (x) {
                            if (!request.valuePrefix() && x.snippet) {
                                x.text = x.displayText;
                                x.snippet = "[" + x.snippet + "]";
                                return;
                            }
                            x.extra = " [";
                            x.text = (x.snippet || x.displayText) + "]";
                            x.snippet = null;
                        });
                    }
                }
                else {
                    var ending = "";
                    var initialPosition = offset;
                    for (var i = initialPosition; i < text.length && !/[\t\n\r]/.test(text[i]); i++) {
                        ending += text[i];
                        if (ending.replace(/\s/g, '') === ":") {
                            proposals.forEach(function (x) {
                                x.text = x.displayText;
                                x.snippet = null;
                                x.extra = null;
                            });
                            break;
                        }
                    }
                    proposals.forEach(function (x) {
                        if (x.isResourceType && !request.valuePrefix() && x.snippet) {
                            x.snippet = x.extra + x.snippet;
                            x.extra = null;
                            x.text = x.displayText;
                        }
                    });
                }
            }
            if (!hasNewLine && proposals && proposals.length > 0) {
                proposals = addDefineInlineProposal2(proposals, hlnode.lowLevel().start(), text);
            }
            if (proposals && isInResourceDescription(attr) && request.prefix() && request.prefix().length > 0) {
                var canBeTemplate = false;
                var canBeTransform1 = 0;
                var canBeTransform2 = 0;
                var txt = "";
                for (var position = offset - 1; position >= 0; position--) {
                    var ch = text[position];
                    if (ch === '\r' || ch === '\n') {
                        break;
                    }
                    if (ch === '<' && text[position - 1] === '<') {
                        canBeTemplate = true;
                        break;
                    }
                    if (ch === '!') {
                        canBeTransform1++;
                    }
                    if (ch === '|' && canBeTransform1 === 1) {
                        canBeTransform2++;
                    }
                    txt = ch + txt;
                }
                if (canBeTemplate && canBeTransform1 === 1 && canBeTransform2 === 1) {
                    var leftPart = new RegExp(/\|\s*!\s*/.source + request.prefix());
                    if (leftPart.test(txt)) {
                        proposals = addTransformers(proposals, request.prefix());
                    }
                }
            }
            return proposals;
        }
        if (kind == search.LocationKind.KEY_COMPLETION ||
            (kind == search.LocationKind.SEQUENCE_KEY_COPLETION && offset > 0 && text.charAt(offset - 1) != '-'
                && text.charAt(offset - 1) != ' ')) {
            if (node.isAttr() || node.isImplicit()) {
                throw new Error("Should be highlevel node at this place");
            }
            if (search.isExampleNode(hlnode)) {
                return examplePropertyCompletion(hlnode, request, provider);
            }
            if (hlnode.property()
                && universeHelpers.isUriParametersProperty(hlnode.property())
                && hlnode.definition() instanceof def.NodeClass) {
                var nm = hlnode.parent().attr("relativeUri");
                if (nm && hlnode.name().substring(0, hlnode.name().length - 1) == request.valuePrefix()) {
                    var runtime = parserApi.utils.parseUrl(nm.value());
                    if (runtime instanceof Array) {
                        if (runtime) {
                            if (isColonNeeded(offset, text)) {
                                var rs = runtime.map(function (x) {
                                    return { text: x + ": \n" + getIndent2(offset, text) + "  " };
                                });
                            }
                            else {
                                var rs = runtime.map(function (x) {
                                    return { text: x };
                                });
                            }
                            return rs;
                        }
                    }
                }
            }
            if (hlnode.property() && universeHelpers.isBaseUriParametersProperty(hlnode.property()) && hlnode.definition() instanceof def.NodeClass) {
                var nm = hlnode.root().attr(universeModule.Universe10.Api.properties.baseUri.name);
                if (nm && hlnode.name().substring(0, hlnode.name().length - 1) == request.valuePrefix()) {
                    var runtime = parserApi.utils.parseUrl(nm.value());
                    if (runtime instanceof Array) {
                        if (runtime) {
                            if (isColonNeeded(offset, text)) {
                                var rs = runtime.map(function (x) {
                                    return { text: x + ": \n" + getIndent2(offset, text) + "  " };
                                });
                            }
                            else {
                                var rs = runtime.map(function (x) {
                                    return { text: x };
                                });
                            }
                            return rs;
                        }
                    }
                }
            }
            //FIXME It still should be improved
            if (hlnode.property() &&
                universeHelpers.isResourcesProperty(hlnode.property())) {
                var nm = hlnode.attr("relativeUri");
                if (nm && hlnode.name().substring(0, hlnode.name().length - 1) == request.valuePrefix()) {
                    if (nm && nm.value().indexOf("{") != -1) {
                        return [{ text: "mediaTypeExtension}" }];
                    }
                    return [];
                }
            }
            var mv = hlnode.property() && hlnode.property().isMultiValue();
            if (hlnode.lowLevel().keyEnd() < offset) {
                mv = false;
            }
            //extra test /*FIXME*/
            var defNode = true;
            if (mv) {
                var ce = hlnode.definition().getAdapter(services.RAMLService).getCanInherit();
                if (ce) {
                    var context = hlnode.computedValue(ce[0]);
                    if (context) {
                        defNode = true;
                        mv = false;
                    }
                }
            }
            return propertyCompletion(hlnode, request, mv, defNode /*we can get 'k' only if we are completing the start of node key*/);
        }
        return [];
    }
    finally {
        provider.level--;
    }
    //return [];
}
function ramlVersionCompletion(request) {
    var prop = ["RAML 0.8", "RAML 1.0"];
    var rs = [];
    var text = request.content.getText();
    var offset = request.position.getOffset();
    var start = text.substr(0, offset);
    if (start.indexOf("#%RAML 1.0 ") == 0) {
        var list = [
            "DocumentationItem",
            "DataType",
            "NamedExample",
            "ResourceType",
            "Trait",
            "SecurityScheme",
            "AnnotationTypeDeclaration",
            "Library",
            "Overlay",
            "Extension"];
        return list.map(function (x) { return { text: x }; });
    }
    prop.forEach(function (x) {
        if (("#%" + x).indexOf(start) != 0) {
            return;
        }
        if (text.trim().indexOf("#%") == 0) {
            if (request.prefix().indexOf("R") != -1) {
                rs.push({ displayText: x, text: x });
            }
            else {
                var pref = text.substring(2, offset);
                if (x.indexOf(pref) == 0) {
                    if (request.prefix() == "1" || request.prefix() == '0') {
                        rs.push({ displayText: x, text: request.prefix() + x.substr(offset - 2) });
                    }
                    else {
                        rs.push({ displayText: x, text: x.substr(offset - 2) });
                    }
                }
            }
        }
        else {
            rs.push({ displayText: x, text: x, extra: "%" });
        }
    });
    return rs;
}
;
function completionKind(request) {
    return parserApi.search.determineCompletionKind(request.content.getText(), request.position.getOffset());
}
function getAstNode(request, contentProvider, clearLastChar, allowNull) {
    if (clearLastChar === void 0) { clearLastChar = true; }
    if (allowNull === void 0) { allowNull = true; }
    var newProjectId = contentProvider.contentDirName(request.content);
    var project = parserApi.project.createProject(newProjectId, contentProvider.fsResolver);
    var offset = request.position.getOffset();
    var text = request.content.getText();
    var kind = completionKind(request);
    if (kind === parserApi.search.LocationKind.KEY_COMPLETION && clearLastChar) {
        text = text.substring(0, offset) + "k:" + text.substring(offset);
    }
    var unit = project.setCachedUnitContent(request.content.getBaseName(), text);
    var ast = unit.highLevel();
    var actualOffset = offset;
    for (var currentOffset = offset - 1; currentOffset >= 0; currentOffset--) {
        var symbol = text[currentOffset];
        if (symbol === ' ' || symbol === '\t') {
            actualOffset = currentOffset - 1;
            continue;
        }
        break;
    }
    var astNode = ast.findElementAtOffset(actualOffset);
    if (!allowNull && !astNode) {
        return ast;
    }
    return astNode;
}
function getIndent(offset, text) {
    var spaces = "";
    for (var i = offset - 1; i >= 0; i--) {
        var c = text.charAt(i);
        if (c == ' ' || c == '\t') {
            if (spaces) {
                spaces += c;
            }
            else {
                spaces = c;
            }
        }
        else if (c == '\r' || c == '\n') {
            return spaces;
        }
        else if (spaces) {
            return "";
        }
    }
    return "";
}
function getIndentWithSequenc(offset, text) {
    var spaces = "";
    for (var i = offset - 1; i >= 0; i--) {
        var c = text.charAt(i);
        if (c == ' ' || c == '\t' || c == '-') {
            if (spaces) {
                spaces += c;
            }
            else {
                spaces = c;
            }
        }
        else if (c == '\r' || c == '\n') {
            return spaces;
        }
        else if (spaces) {
            return "";
        }
    }
    return "";
}
function getIndent2(offset, text) {
    var spaces = "";
    for (var i = offset - 1; i >= 0; i--) {
        var c = text.charAt(i);
        if (c == ' ' || c == '\t') {
            if (spaces) {
                spaces += c;
            }
            else {
                spaces = c;
            }
        }
        else if (c == '\r' || c == '\n') {
            return spaces;
        }
    }
}
function pathCompletion(request, contentProvider, attr, hlNode, custom) {
    var prefix = request.valuePrefix();
    if (prefix.indexOf("#") === -1) {
        return pathPartCompletion(request, contentProvider, attr, hlNode, custom);
    }
    else {
        return pathReferencePartCompletion(request, contentProvider, attr, hlNode, custom);
    }
}
function pathPartCompletion(request, contentProvider, attr, hlNode, custom) {
    var prefix = request.valuePrefix();
    var dn = contentProvider.contentDirName(request.content);
    var ll = contentProvider.resolve(dn, prefix);
    var indexOfDot = ll.lastIndexOf('.');
    var indexOfSlash = ll.lastIndexOf('/');
    if (!(indexOfDot > 0 && (indexOfDot > indexOfSlash || indexOfSlash < 0))) {
        indexOfDot = -1;
    }
    var typedPath = ll;
    if (ll) {
        dn = contentProvider.dirName(ll);
        if (contentProvider.exists(ll) && contentProvider.isDirectory(ll)) {
            dn = ll;
        }
    }
    var res = [];
    var known = !custom;
    if (attr) {
        if (custom) {
            if (attr.name() === 'example') {
                res = res.concat(fromDir(prefix, dn, "examples", contentProvider));
                known = true;
            }
            if (attr.name() === 'value' &&
                parserApi.universeHelpers.isGlobalSchemaType(attr.parent().definition())) {
                res = res.concat(fromDir(prefix, dn, "schemas", contentProvider));
                known = true;
            }
        }
    }
    if (!attr) {
        if (custom) {
            if (parserApi.universeHelpers.isTraitType(hlNode.definition())) {
                res = res.concat(fromDir(prefix, dn, "traits", contentProvider));
                known = true;
            }
            if (parserApi.universeHelpers.isResourceTypeType(hlNode.definition())) {
                res = res.concat(fromDir(prefix, dn, "resourceTypes", contentProvider));
                known = true;
            }
            if (parserApi.universeHelpers.isSecuritySchemaType(hlNode.definition())) {
                res = res.concat(fromDir(prefix, dn, "securitySchemes", contentProvider));
                known = true;
            }
            if (parserApi.universeHelpers.isGlobalSchemaType(hlNode.definition())) {
                res = res.concat(fromDir(prefix, dn, "schemas", contentProvider));
                known = true;
            }
        }
    }
    if (!known || !custom) {
        if (contentProvider.exists(dn) && contentProvider.isDirectory(dn)) {
            var dirContent = contentProvider.readDir(dn);
            res = res.concat(dirContent.filter(function (x) {
                try {
                    var fullPath = contentProvider.resolve(dn, x);
                    if (fullPath.indexOf(typedPath) === 0) {
                        return true;
                    }
                }
                catch (exception) {
                    return false;
                }
            }).map(function (x) {
                return { text: indexOfDot > 0 ? contentProvider.resolve(dn, x).substr(indexOfDot + 1) : x };
            }));
        }
    }
    return res;
}
function fromDir(prefix, dn, dirToLook, contentProvider) {
    var pss = contentProvider.resolve(dn, dirToLook);
    if (contentProvider.exists(pss)) {
        var dirContent = contentProvider.readDir(pss);
        var proposals = dirContent.map(function (x) { return { text: x, replacementPrefix: prefix, extra: "./" + dirToLook + "/" }; });
        return proposals;
    }
    return [];
}
function pathReferencePartCompletion(request, contentProvider, attr, hlNode, custom) {
    var prefix = request.valuePrefix();
    var includePath = parserApi.schema.getIncludePath(prefix);
    var includeReference = parserApi.schema.getIncludeReference(prefix);
    if (!includePath || !includeReference) {
        return [];
    }
    var includeUnit = attr.lowLevel().unit().resolve(includePath);
    if (!includeUnit) {
        return [];
    }
    var content = includeUnit.contents();
    if (!content) {
        return [];
    }
    try {
        var proposals = parserApi.schema.completeReference(includePath, includeReference, content);
        return proposals.map(function (proposal) {
            return {
                text: proposal
            };
        });
    }
    catch (Error) {
        console.log(Error);
    }
    return [];
}
function isColonNeeded(offset, text) {
    var needColon = true;
    for (var i = offset > 0 ? offset - 1 : 0; i < text.length; i++) {
        var chr = text.charAt(i);
        if (chr == ' ' || chr == '\r' || chr == '\n') {
            break;
        }
        if (chr == ':') {
            needColon = false;
        }
    }
    return needColon;
}
function isAllowed(node, x) {
    var ok = true;
    x.getContextRequirements().forEach(function (y) {
        if (y.name.indexOf('(') !== -1) {
            return;
        }
        var vl = node.computedValue(y.name);
        if (vl) {
            ok = ok && (vl == y.value);
        }
        else {
            if (y.value) {
                ok = false;
            }
        }
    });
    return ok;
}
function propertyCompletion(node, request, mv, c, hasNewLine) {
    if (hasNewLine === void 0) { hasNewLine = true; }
    var hlnode = node;
    var notAKey = false;
    var onlyKey = false;
    var text = request.content.getText();
    var offset = request.position.getOffset();
    if (hasNewLine) {
        var is = getIndentWithSequenc(node.lowLevel().keyStart(), text);
        if (is == undefined) {
            is = "";
        }
        var i2s = getIndentWithSequenc(offset, text);
        var i1 = is.length;
        var i2 = i2s.length;
        if (i1 == i2 && node.parent()) {
            if (node.property().getAdapter(parserApi.ds.RAMLPropertyService).isMerged()) {
                hlnode = hlnode.parent();
            }
            else {
                notAKey = false;
                onlyKey = true;
            }
        }
        if (i2 > i1) {
            notAKey = true;
            if (i2 >= i1 + 4) {
                onlyKey = true;
                notAKey = false;
            }
        }
        while (i2 < i1 && hlnode.parent()) {
            hlnode = hlnode.parent();
            i1 = i1 - 2;
        }
    }
    var needColon = isColonNeeded(offset, text);
    var ks = needColon ? ": " : "";
    var props = hlnode.definition().allProperties();
    //basic filtering
    props = props.filter(function (x) { return !x.getAdapter(parserApi.ds.RAMLPropertyService).isKey() && !x.getAdapter(parserApi.ds.RAMLPropertyService).isMerged() && !x.getAdapter(services.RAMLPropertyService).isSystem(); });
    //contextual filtering
    props = props.filter(function (x) { return isAllowed(hlnode, x); });
    var existing = {};
    hlnode.attrs().forEach(function (x) {
        existing[x.name()] = true;
    });
    props = props.filter(function (x) { return !existing[x.nameId()]; }).filter(function (x) { return !x.isAnnotation(); });
    if (node.definition().isAssignableFrom(parserApi.universes.Universe10.TypeDeclaration.name)) {
        if (!node.definition().isAssignableFrom("ObjectTypeDeclaration")) {
            if (!node.attr("type")) {
                var q = node.definition().universe().type("ObjectTypeDeclaration");
                if (q) {
                    props.push(q.property("properties"));
                }
            }
        }
    }
    //TODO MAKE IT BETTER (actually we need to filter out and guess availabe keys)
    var rs = [];
    if (!mv && !onlyKey) {
        rs = props.map(function (x) {
            var complextionText = x.nameId() + ks;
            if (!x.range().hasValueTypeInHierarchy() && needColon) {
                complextionText += "\n" + getIndent(offset, text) + "  ";
            }
            return { text: complextionText, displayText: x.nameId(), description: x.description() };
        });
    }
    if (c) {
        hlnode.definition().allProperties().filter(function (x) { return x.getAdapter(parserApi.ds.RAMLPropertyService).isMerged() || x.isFromParentKey(); }).forEach(function (p) {
            if (onlyKey) {
                if (!p.isFromParentKey()) {
                    return;
                }
            }
            if (notAKey) {
                if (p.isFromParentKey()) {
                    return;
                }
            }
            var prop = p;
            var oftenKeys = p.getOftenKeys();
            if (!oftenKeys) {
                var sug = p.suggester();
                if (sug) {
                    oftenKeys = sug(hlnode);
                }
            }
            if (!oftenKeys) {
                oftenKeys = p.enumOptions();
            }
            if (hlnode.property() &&
                parserApi.universeHelpers.isBodyProperty(hlnode.property())) {
                if (!oftenKeys) {
                    if (parserApi.universeHelpers.isResponseType(hlnode.property().domain())) {
                        oftenKeys = ["application/json", "application/xml"];
                    }
                    if (parserApi.universeHelpers.isMethodBaseType(hlnode.property().domain())
                        || parserApi.universeHelpers.isMethodType(hlnode.property().domain())) {
                        oftenKeys = ["application/json", "application/xml", "multipart/form-data", "application/x-www-form-urlencoded"];
                    }
                }
            }
            if (oftenKeys) {
                oftenKeys.forEach(function (y) {
                    var cs = prop.valueDocProvider();
                    var description = "";
                    if (cs) {
                        description = cs(y);
                    }
                    if (needColon) {
                        rs.push({
                            text: y + ":" + "\n" + getIndent(offset, text) + "  ",
                            description: description,
                            displayText: y,
                            prefix: y.indexOf("/") >= 0 ? request.valuePrefix() : null
                        });
                    }
                    else {
                        rs.push({
                            text: y,
                            description: description,
                            displayText: y,
                            prefix: y.indexOf("/") >= 0 ? request.valuePrefix() : null
                        });
                    }
                });
            }
        });
    }
    return rs;
}
function valueCompletion(node, attr, request, provider) {
    var hlnode = node;
    var text = request.content.getText();
    var offset = request.position.getOffset();
    if (attr) {
        var p = attr.property();
        var vl = attr.value();
        if (typeof vl === "object" && vl) {
            var innerNode = vl.toHighLevel();
            if (innerNode) {
                return getSuggestions(provider.currentRequest, provider, findASTNodeByOffset(innerNode, request));
            }
            else if (parserApi.search.isExampleNodeContent(attr)) {
                var contentType = parserApi.search.findExampleContentType(attr);
                if (contentType) {
                    var documentationRoot = parserApi.search.parseDocumentationContent(attr, contentType);
                    if (documentationRoot) {
                        return getSuggestions(provider.currentRequest, provider, findASTNodeByOffset(documentationRoot, request));
                    }
                }
            }
        }
        if (p) {
            var vls = enumValues(p, hlnode);
            if (p.isAllowNull()) {
                vls.push({ text: 'null', description: 'null means - that no value is allowed' });
            }
            if (!vls || vls.length == 0) {
                var oftenKeys = p.getOftenKeys();
                if (oftenKeys) {
                    return oftenKeys.map(function (x) {
                        return { text: x, displayText: x };
                    });
                }
            }
            if (universeHelpers.isExampleProperty(p)
                && universeHelpers.isBodyLikeType(hlnode.definition())) {
                if (!testVal(attr.value(), offset, text)) {
                    return;
                }
                var rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) { x.extra = "!include ./examples/"; x.displayText = "!include ./examples/" + x.text; return x; });
                rs = addDefineInlineProposal(rs, attr.lowLevel().start(), text);
                return rs;
            }
            if (universeHelpers.isValueProperty(p)
                && universeHelpers.isGlobalSchemaType(hlnode.definition())) {
                if (!testVal(attr.value(), offset, text)) {
                    return;
                }
                rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) { x.extra = "!include ./schemas/"; x.displayText = "!include ./schemas/" + x.text; return x; });
                rs = addDefineInlineProposal(rs, attr.lowLevel().start(), text);
            }
            if (vls) {
                return vls;
            }
        }
        return [];
    }
    else {
        //FIXME (To DEF)
        if (universeHelpers.isGlobalSchemaType(hlnode.definition())) {
            rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) { x.extra = "!include ./schemas/"; x.displayText = "!include ./schemas/" + x.text; return x; });
            rs = addDefineInlineProposal(rs, hlnode.lowLevel().start(), text);
        }
        if (universeHelpers.isTraitType(hlnode.definition())) {
            rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) { x.extra = "!include ./traits/"; x.displayText = "!include ./traits/" + x.text; return x; });
            rs = addDefineInlineProposal2(rs, hlnode.lowLevel().start(), text);
            return rs;
        }
        if (universeHelpers.isResourceTypeType(hlnode.definition())) {
            var rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) { x.extra = "!include ./resourceTypes/"; x.displayText = "!include ./resourceTypes/" + x.text; return x; });
            rs = addDefineInlineProposal2(rs, hlnode.lowLevel().start(), text);
            return rs;
        }
        if (universeHelpers.isSecuritySchemaType(hlnode.definition())) {
            var rs = pathCompletion(request, provider.contentProvider, attr, hlnode, true).map(function (x) { x.extra = "!include ./securitySchemes/"; x.displayText = "!include ./securitySchemes/" + x.text; return x; });
            rs = addDefineInlineProposal2(rs, hlnode.lowLevel().start(), text);
            return rs;
        }
        if (universeHelpers.isExampleSpecType(hlnode.definition())) {
            console.log('Buzzinga!!!');
            return examplePropertyCompletion(hlnode, request, provider);
        }
    }
}
exports.valueCompletion = valueCompletion;
function findASTNodeByOffset(ast, request) {
    var text = request.content.getText();
    var cm = request.position.getOffset();
    for (var pm = cm - 1; pm >= 0; pm--) {
        var c = text[pm];
        if (c == ' ' || c == '\t') {
            cm = pm;
            continue;
        }
        break;
    }
    var astNode = ast.findElementAtOffset(cm);
    return astNode;
}
function enumValues(property, parentNode) {
    if (parentNode) {
        if (property.getAdapter(parserApi.ds.RAMLPropertyService).isTypeExpr()) {
            var associatedType = parentNode.associatedType();
            var parentDefinition = parentNode.definition();
            var noArraysOrPrimitives;
            var typeProperty = parentNode.attr(parserApi.universes.Universe10.TypeDeclaration.properties.type.name);
            var typePropertyValue = typeProperty && typeProperty.value();
            var typeProperties = parentNode.children() && parentNode.children().filter(function (child) { return child.isAttr() && parserApi.universeHelpers.isTypeProperty(child.property()); });
            var definitionNodes = parserApi.search.globalDeclarations(parentNode).filter(function (node) {
                if (parserApi.universeHelpers.isGlobalSchemaType(node.definition())) {
                    return true;
                }
                var superTypesOfProposed = node.definition().allSuperTypes();
                if (_.find(superTypesOfProposed, function (supertype) { return parserApi.universeHelpers.isTypeDeclarationType(supertype); })) {
                    var isMultiValue = typePropertyValue && property && property.isMultiValue() && typeProperties && typeProperties.length > 1;
                    if (isMultiValue) {
                        if (!associatedType) {
                            try {
                                associatedType = parentNode.localType();
                            }
                            catch (exception) {
                                console.log(exception);
                            }
                        }
                        if (associatedType && !parentDefinition.hasUnionInHierarchy()) {
                            var supertypes = associatedType.superTypes().filter(function (supertype) { return !supertype.isAssignableFrom('unknown'); });
                            if (supertypes) {
                                var isExtendsObject = _.find(supertypes, function (supertype) { return isObject(supertype); });
                                var isExtendsPrimitive = _.find(supertypes, function (supertype) { return isPrimitive(supertype); });
                                var isExtendsArray = _.find(supertypes, function (supertype) { return isArray(supertype); }) || (parentDefinition && isArray(parentDefinition));
                                var noObjects = isExtendsArray || isExtendsPrimitive;
                                noArraysOrPrimitives = isExtendsObject || noObjects;
                                if (_.find(supertypes, function (supertype) { return parserApi.search.qName(node, parentNode) === supertype.nameId(); })) {
                                    return false;
                                }
                                if (noArraysOrPrimitives && (isPrimitive(node.definition()) || isArray(node.definition()))) {
                                    return false;
                                }
                                if (noObjects && isObject(node.definition())) {
                                    return false;
                                }
                            }
                        }
                        if (parentDefinition.hasUnionInHierarchy()) {
                            var unionClasses = allClassesForUnion(parentDefinition);
                            if (_.find(unionClasses, function (unionPart) { return parserApi.search.qName(node, parentNode) === unionPart.nameId(); })) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
                return universeHelpers.isTypeDeclarationType(node.definition()) && node.property().nameId() === 'models';
            });
            var result = definitionNodes.map(function (node) {
                return {
                    text: search.qName(node, parentNode),
                    description: ""
                };
            });
            var typeDeclarationType = property.domain().universe().type("TypeDeclaration");
            //var annotationTypeDeclaration = property.domain().universe().type("AnnotationTypeDeclaration");
            if (typeDeclarationType) {
                var subTypes = typeDeclarationType.allSubTypes();
                result = result.concat(subTypes.filter(function (subType) {
                    if (noArraysOrPrimitives && (isPrimitive(subType) || isArray(subType))) {
                        return false;
                    }
                    return true;
                }).map(function (subType) {
                    return {
                        text: subType.getAdapter(services.RAMLService).descriminatorValue(),
                        description: subType.description()
                    };
                }));
            }
            return result;
        }
        if (universeHelpers.isSchemaStringType(property.range())) {
            if (property.range().universe().version() === "RAML10") {
                var definitionNodes = search.globalDeclarations(parentNode).filter(function (node) {
                    if (universeHelpers.isGlobalSchemaType(node.definition())) {
                        return true;
                    }
                    var superTypesOfProposed = node.definition().allSuperTypes();
                    if (_.find(superTypesOfProposed, function (x) { return universeHelpers.isTypeDeclarationType(x); })) {
                        return true;
                    }
                    return universeHelpers.isTypeDeclarationType(node.definition()) && node.property().nameId() === 'models';
                });
                var result = definitionNodes.map(function (node) {
                    return { text: search.qName(node, parentNode), description: "" };
                });
                var subTypes = search.subTypesWithLocals(property.domain().universe().type("TypeDeclaration"), parentNode);
                result = result.concat(subTypes.map(function (subType) {
                    return {
                        text: subType.getAdapter(services.RAMLService).descriminatorValue(),
                        description: subType.description()
                    };
                }));
                return result;
            }
        }
        if (property.isDescriminator()) {
            var subTypes = search.subTypesWithLocals(property.domain(), parentNode);
            return subTypes.map(function (subType) {
                return {
                    text: subType.getAdapter(services.RAMLService).descriminatorValue(),
                    description: subType.description()
                };
            });
        }
        if (property.isReference()) {
            return search.nodesDeclaringType(property.referencesTo(), parentNode).map(function (subType) {
                return nodeToProposalInfo(subType, parentNode);
            });
        }
        if (property.range().hasValueTypeInHierarchy()) {
            var valueTypeAdapter = property.range().getAdapter(services.RAMLService);
            if (valueTypeAdapter.globallyDeclaredBy().length > 0) {
                var definitionNodes = search.globalDeclarations(parentNode).filter(function (proposedNode) {
                    var proposedDefinition = proposedNode.definition();
                    return _.find(valueTypeAdapter.globallyDeclaredBy(), function (globalDefinition) { return globalDefinition == proposedDefinition; }) != null;
                });
                return definitionNodes.map(function (proposedNode) { return nodeToProposalInfo(proposedNode, parentNode); });
            }
            if (universeHelpers.isBooleanTypeType(property.range())) {
                return ["false", "true"].map(function (value) {
                    return {
                        text: value
                    };
                });
            }
            var propertyNode = property.node && property.node();
            if (propertyNode) {
                var suggestions = _.filter(propertyNode.children(), function (child) {
                    return child.name && child.value && child.property() && universeHelpers.isEnumProperty(child.property());
                }).map(function (child) { return ({ text: child.value() }); });
                return suggestions;
            }
        }
    }
    return search.enumValues(property, parentNode).map(function (proposed) {
        return {
            text: proposed
        };
    });
}
function isPrimitive(definition) {
    var isPrimitive = !definition.isArray() && !isObject(definition) && !definition.hasUnionInHierarchy() && definition.key() !== universeModule.Universe10.TypeDeclaration;
    return isPrimitive;
}
function isObject(definition) {
    return definition.isAssignableFrom(universeModule.Universe10.ObjectTypeDeclaration.name) || definition.isAssignableFrom('object');
}
function isArray(definition) {
    return definition.isAssignableFrom(universeModule.Universe10.ArrayTypeDeclaration.name);
}
function allClassesForUnion(definition) {
    var result = [];
    if (!definition || !definition.isUnion()) {
        return definition ? [definition] : result;
    }
    if (definition.left) {
        result.push(definition.left);
        return result.concat(allClassesForUnion(definition.right));
    }
}
function addDefineInlineProposal(rs, offset, text) {
    rs = [{ displayText: "Define Inline", text: "|\n" + leadingIndent(offset - 1, text) + "  " }].concat(rs);
    return rs;
}
function addDefineInlineProposal2(rs, offset, text) {
    rs = [{ displayText: "Define Inline", text: "\n" + leadingIndent(offset - 1, text) + "  " }].concat(rs);
    return rs;
}
function leadingIndent(pos, text) {
    var leading = "";
    while (pos > 0) {
        var ch = text[pos];
        if (ch == '\r' || ch == '\n' || (ch != ' ' && ch != '-'))
            break;
        leading = leading + ' ';
        pos--;
    }
    return leading;
}
;
function getProposalText(proposal) {
    if (proposal.text) {
        return proposal.text;
    }
    if (proposal.snippet) {
        return proposal.snippet;
    }
    return proposal.displayText;
}
function updateProposalText(proposal, textToUpdateWith) {
    if (proposal.text) {
        proposal.text = textToUpdateWith;
        return;
    }
    if (proposal.snippet) {
        proposal.snippet = textToUpdateWith;
        return;
    }
    proposal.displayText = textToUpdateWith;
}
function isSiblingExists(attr, siblingName) {
    var parent = attr.parent && attr.parent();
    if (!parent) {
        return false;
    }
    var propertyName = attr.name && attr.name();
    if (!propertyName) {
        return false;
    }
    var siblings = parent.attributes && parent.attributes(propertyName);
    if (!siblings) {
        return false;
    }
    if (siblings.length === 0) {
        return false;
    }
    var names = [];
    siblings.forEach(function (sibling) {
        var name = sibling.value && sibling.value() && sibling.value().valueName && sibling.value().valueName();
        if (!name) {
            return;
        }
        names.push(name);
    });
    return _.find(names, function (name) { return siblingName === name; });
}
function isSquareBracketExpected(attr) {
    if (!attr) {
        return false;
    }
    if (!attr.definition()) {
        return false;
    }
    if (!attr.property()) {
        return false;
    }
    if (!attr.definition().isAssignableFrom(universeModule.Universe10.TraitRef.name)) {
        return false;
    }
    return true;
}
function isInResourceDescription(obj) {
    var definition = obj && obj.definition ? obj.definition() : null;
    if (definition) {
        var name = definition.nameId();
        if (name === 'Api') {
            return false;
        }
        if (name === 'ResourceType' || name === 'Trait') {
            return true;
        }
        var parent = obj.parent();
        if (!parent) {
            return false;
        }
        return isInResourceDescription(parent);
    }
    return false;
}
var transformers = parserApi.utils.getTransformerNames();
var addTransformers = function (proposals, prefix) {
    var result = [];
    transformers.filter(function (transformer) {
        return transformer.indexOf(prefix) === 0;
    }).forEach(function (transformer) {
        result.push({ displayText: transformer, text: transformer });
    });
    return result.concat(proposals);
};
function testVal(vl, offset, text) {
    if (vl && vl.length > 0) {
        var q = vl.trim();
        if (q.indexOf("{") == 0) {
            return false;
        }
        if (q.indexOf("<") == 0) {
            return false;
        }
        if (q.indexOf("[") == 0) {
            return false;
        }
    }
    for (var i = offset; i >= 0; i--) {
        var c = text[i];
        if (c == ':') {
            return true;
        }
        if (c == '|') {
            return false;
        }
        if (c == "'") {
            return false;
        }
        if (c == '"') {
            return false;
        }
    }
    return true;
}
function nodeToProposalInfo(x, c) {
    var isResourceType = false;
    var d = x.attr("description");
    var ds = "";
    if (d) {
        ds = d.value();
    }
    else {
        d = x.attr("usage");
        if (d) {
            ds = d.value();
        }
    }
    var tr = x.localType();
    var req = tr.allProperties().filter(function (x) { return x.isRequired() && !x.getAdapter(services.RAMLPropertyService).isKey(); });
    var txt = search.qName(x, c);
    if (!universeHelpers.isAnnotationTypeType(x.definition())) {
        if (req.length > 0) {
            txt += ": {";
            txt += req.map(function (x) { return x.nameId() + " : "; }).join(", ") + "}";
            var extra = "";
            if (universeHelpers.isResourceTypeType(x.definition())) {
                txt = "" + txt + " }";
                extra = " { ";
                isResourceType = true;
            }
        }
    }
    return {
        displayText: search.qName(x, c),
        snippet: txt,
        description: ds,
        extra: extra,
        isResourceType: isResourceType
    };
}
function examplePropertyCompletion(node, request, provider) {
    if (!search.isExampleNode(node)) {
        return [];
    }
    var contentType = search.findExampleContentType(node);
    if (!contentType)
        return [];
    var parsedExample = search.parseStructuredExample(node, contentType);
    if (!parsedExample)
        return [];
    return getSuggestions(request, provider, findASTNodeByOffset(parsedExample, request));
}
function postProcess(providerSuggestions, request) {
    var prepared = postProcess1(providerSuggestions, request);
    var added = [];
    var result = [];
    prepared.forEach(function (item) {
        var value = suggestionValue(item);
        if (added.indexOf(value) < 0) {
            result.push(item);
            added.push(value);
        }
    });
    return result;
}
exports.postProcess = postProcess;
function postProcess1(providerSuggestions, request) {
    var hasDeprecations, hasEmpty, suggestion, _i, _len;
    if (providerSuggestions == null) {
        return;
    }
    if (hasDeprecations) {
        providerSuggestions = providerSuggestions.map(function (suggestion) {
            var newSuggestion, _ref1, _ref2;
            newSuggestion = {
                text: (_ref1 = suggestion.text) != null ? _ref1 : suggestion.word,
                snippet: suggestion.snippet,
                replacementPrefix: (_ref2 = suggestion.replacementPrefix) != null ? _ref2 : suggestion.prefix,
                className: suggestion.className,
                type: suggestion.type
            };
            if ((newSuggestion.rightLabelHTML == null) && suggestion.renderLabelAsHtml) {
                newSuggestion.rightLabelHTML = suggestion.label;
            }
            if ((newSuggestion.rightLabel == null) && !suggestion.renderLabelAsHtml) {
                newSuggestion.rightLabel = suggestion.label;
            }
            return newSuggestion;
        });
    }
    hasEmpty = false;
    for (_i = 0, _len = providerSuggestions.length; _i < _len; _i++) {
        suggestion = providerSuggestions[_i];
        if (!(suggestion.snippet || suggestion.text)) {
            hasEmpty = true;
        }
        if (suggestion.replacementPrefix == null) {
            suggestion.replacementPrefix = getDefaultReplacementPrefix(request.prefix());
        }
    }
    if (hasEmpty) {
        providerSuggestions = (function () {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = providerSuggestions.length; _j < _len1; _j++) {
                suggestion = providerSuggestions[_j];
                if (suggestion.snippet || suggestion.text) {
                    _results.push(suggestion);
                }
            }
            return _results;
        })();
    }
    providerSuggestions = filterSuggestions(providerSuggestions, request);
    return providerSuggestions;
}
var fuzzaldrinProvider = require('fuzzaldrin-plus');
function filterSuggestions(suggestions, _arg) {
    var firstCharIsMatch, i, prefix, prefixIsEmpty, results, score, suggestion, suggestionPrefix, text, _i, _len, _ref1;
    prefix = _arg.prefix();
    results = [];
    for (i = _i = 0, _len = suggestions.length; _i < _len; i = ++_i) {
        suggestion = suggestions[i];
        suggestion.sortScore = Math.max(-i / 10 + 3, 0) + 1;
        suggestion.score = null;
        text = suggestion.snippet || suggestion.text;
        suggestionPrefix = (_ref1 = suggestion.replacementPrefix) != null ? _ref1 : prefix;
        prefixIsEmpty = !suggestionPrefix || suggestionPrefix === ' ';
        firstCharIsMatch = !prefixIsEmpty && suggestionPrefix[0].toLowerCase() === text[0].toLowerCase();
        if (prefixIsEmpty) {
            results.push(suggestion);
        }
        if (firstCharIsMatch && (score = fuzzaldrinProvider.score(text, suggestionPrefix)) > 0) {
            suggestion.score = score * suggestion.sortScore;
            results.push(suggestion);
        }
    }
    results.sort(reverseSortOnScoreComparator);
    return results;
}
var wordPrefixRegex = /^\w+[\w-]*$/;
function reverseSortOnScoreComparator(a, b) {
    var _ref1, _ref2;
    return ((_ref1 = b.score) != null ? _ref1 : b.sortScore) - ((_ref2 = a.score) != null ? _ref2 : a.sortScore);
}
;
function getDefaultReplacementPrefix(prefix) {
    if (wordPrefixRegex.test(prefix)) {
        return prefix;
    }
    else {
        return '';
    }
}
;
function suggestionValue(suggestion) {
    return (suggestion && (suggestion.displayText || suggestion.text)) || null;
}
var prefixRegex = /(\b|['"~`!@#\$%^&*\(\)\{\}\[\]=\+,\/\?>])((\w+[\w-]*)|([.:;[{(< ]+))$/;
function getPrefix(request) {
    var line, _ref1;
    line = getLine(request);
    return ((_ref1 = prefixRegex.exec(line)) != null ? _ref1[2] : void 0) || '';
}
exports.getPrefix = getPrefix;
function getLine(request) {
    var offset = request.position.getOffset();
    var text = request.content.getText();
    for (var i = offset - 1; i >= 0; i--) {
        var c = text.charAt(i);
        if (c === '\r' || c === '\n' || c === ' ' || c === '\t') {
            return text.substring(i + 1, offset);
        }
    }
    return "";
}
var ResolvedProvider = (function () {
    function ResolvedProvider(resolver) {
        this.resolver = resolver;
        this.fsResolver = resolver;
    }
    ResolvedProvider.prototype.contentDirName = function (content) {
        return this.resolver.dirname(content.getPath());
    };
    ResolvedProvider.prototype.dirName = function (path) {
        return this.resolver.dirname(path);
    };
    ResolvedProvider.prototype.exists = function (path) {
        return this.resolver.exists(path);
    };
    ResolvedProvider.prototype.resolve = function (contextPath, relativePath) {
        return this.resolver.resolve(contextPath, relativePath);
    };
    ResolvedProvider.prototype.isDirectory = function (path) {
        return this.resolver.isDirectory(path);
    };
    ResolvedProvider.prototype.readDir = function (path) {
        return this.resolver.list(path);
    };
    return ResolvedProvider;
}());
function getContentProvider(resolver) {
    return new ResolvedProvider(resolver);
}
exports.getContentProvider = getContentProvider;
//# sourceMappingURL=completionProvider.js.map