"use strict";
var Node = (function () {
    function Node(parent, data, view, container) {
        this.parent = parent;
        this.data = data;
        this.view = view;
        this.container = container;
        this.children = [];
    }
    Node.prototype.indexOf = function (predicate) {
        for (var i = 0; i < this.children.length; i++)
            if (predicate(this.children[i]) == true)
                return i;
        return -1;
    };
    Node.prototype.addChild = function (child, index) {
        if (index == null)
            index = this.children.length;
        else if (index < 0 || index > this.children.length)
            throw new Error("IncorrectArgument");
        this.children.splice(index, 0, child);
    };
    Node.prototype.removeChild = function (element) {
        if (typeof (element) == "number") {
            var index = element;
            if (index < 0 || index > this.children.length)
                throw new Error("IncorrectArgument");
            this.children.splice(index, 1);
        }
        else {
            var index = this.indexOf(function (x) { return x == element; });
            this.removeChild(index);
        }
    };
    return Node;
}());
exports.Node = Node;
var TreeModel = (function () {
    function TreeModel(rootComponent) {
        this.root = new Node();
        this.root.container = rootComponent;
        this.clear();
    }
    TreeModel.prototype.find = function (parent) {
        if (parent == null)
            return this.root;
        return this.flat.get(parent);
    };
    TreeModel.prototype.clear = function () {
        this.root.children = [];
        this.flat = new Map();
    };
    TreeModel.prototype.insert = function (element, parent, neighbour, after) {
        if (after === void 0) { after = false; }
        var node = new Node(parent, element);
        if (after)
            this.insertAfter(node, parent, neighbour);
        else
            this.insertBefore(node, parent, neighbour);
        this.flat.set(element, node);
    };
    TreeModel.prototype.insertBefore = function (node, parent, before) {
        var index = before ? parent.indexOf(function (x) { return x == before; }) : null;
        parent.addChild(node, index);
    };
    TreeModel.prototype.insertAfter = function (node, parent, after) {
        var index = after ? parent.indexOf(function (x) { return x == after; }) : -1;
        parent.addChild(node, index + 1);
    };
    TreeModel.prototype.remove = function (node) {
        node.parent.removeChild(node);
    };
    TreeModel.prototype.get = function (element, parent) {
        if (parent)
            return parent.children[parent.indexOf(function (e) { return e.data == element; })];
        else
            return this.find(element);
    };
    TreeModel.prototype.registerViews = function (element, view, container) {
        var node = this.find(element);
        if (!node)
            throw "RegisterViewException";
        node.container = container;
        node.view = view;
    };
    TreeModel.prototype.patch = function (before, after) {
        var node = this.find(before);
        if (node)
            node.data = after;
        this.flat.set(after, node);
        this.flat.delete(before);
    };
    return TreeModel;
}());
exports.TreeModel = TreeModel;
//# sourceMappingURL=treeModel.js.map