
import ll = require("../lowLevelAST");
import hl = require("../highLevelAST");
import jsyaml = require("../jsyaml/jsyaml2lowLevel");
import proxy = require("./LowLevelASTProxy");
import namespaceResolver = require("../ast.core/namespaceResolver");
export declare class ReferencePatcher {
    process(hlNode: hl.IHighLevelNode, rootNode?: hl.IHighLevelNode, removeUses?: boolean, patchNodeName?: boolean): void;
    patchReferences(node: hl.IHighLevelNode, rootNode?: hl.IHighLevelNode, resolver?: namespaceResolver.NamespaceResolver, units?: ll.ICompilationUnit[]): void;
    patchReferenceAttr(attr: hl.IAttribute, rootNode: hl.IHighLevelNode, resolver: namespaceResolver.NamespaceResolver, units: ll.ICompilationUnit[]): void;
    patchType(node: hl.IHighLevelNode, rootNode: hl.IHighLevelNode, resolver: namespaceResolver.NamespaceResolver, units: ll.ICompilationUnit[]): void;
    private patchTypeName(stringToPatch, rootUnit, units, resolver, transformer, isAnnotation?);
    patchNodeName(hlNode: hl.IHighLevelNode, rootUnit: ll.ICompilationUnit, resolver: namespaceResolver.NamespaceResolver): void;
    patchValue(value: string, rootUnit: ll.ICompilationUnit, resolver: namespaceResolver.NamespaceResolver, units: ll.ICompilationUnit[]): string;
    patchUses(node: ll.ILowLevelASTNode, resolver: namespaceResolver.NamespaceResolver): void;
    removeUses(node: ll.ILowLevelASTNode): void;
    resetTypes(hlNode: hl.IHighLevelNode): void;
    appendUnitIfNeeded(node: hl.IParseResult | ll.ICompilationUnit, units: ll.ICompilationUnit[]): boolean;
    popUnitIfNeeded(units: ll.ICompilationUnit[], appended: boolean): void;
}
export declare function patchMethodIs(node: hl.IHighLevelNode, traits: {
    node: ll.ILowLevelASTNode;
    transformer: proxy.ValueTransformer;
}[]): proxy.LowLevelCompositeNode;
export declare function prepareTraitRefNode(llNode: ll.ILowLevelASTNode, llParent: ll.ILowLevelASTNode): jsyaml.ASTNode;
