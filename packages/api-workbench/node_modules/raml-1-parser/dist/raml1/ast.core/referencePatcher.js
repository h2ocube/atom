"use strict";
var hlimpl = require("../highLevelImpl");
var yaml = require("yaml-ast-parser");
var jsyaml = require("../jsyaml/jsyaml2lowLevel");
var proxy = require("./LowLevelASTProxy");
var universeDef = require("../tools/universe");
var _ = require("underscore");
var universeHelpers = require("../tools/universeHelpers");
var namespaceResolver = require("../ast.core/namespaceResolver");
var def = require("raml-definition-system");
var typeExpressions = def.rt.typeExpressions;
var ReferencePatcher = (function () {
    function ReferencePatcher() {
    }
    ReferencePatcher.prototype.process = function (hlNode, rootNode, removeUses, patchNodeName) {
        if (rootNode === void 0) { rootNode = hlNode; }
        if (removeUses === void 0) { removeUses = false; }
        if (patchNodeName === void 0) { patchNodeName = false; }
        var resolver = hlNode.lowLevel().unit().project().namespaceResolver();
        this.patchReferences(hlNode, rootNode, resolver);
        if (patchNodeName) {
            this.patchNodeName(hlNode, rootNode.lowLevel().unit(), resolver);
        }
        if (removeUses) {
            this.removeUses(hlNode.lowLevel());
        }
        else {
            this.patchUses(hlNode.lowLevel(), resolver);
        }
        this.resetTypes(hlNode);
        hlNode.resetChildren();
    };
    ReferencePatcher.prototype.patchReferences = function (node, rootNode, resolver, units) {
        if (rootNode === void 0) { rootNode = node; }
        if (resolver === void 0) { resolver = new namespaceResolver.NamespaceResolver(); }
        if (units === void 0) { units = [rootNode.lowLevel().unit()]; }
        var isNode;
        if (node.definition().property(universeDef.Universe10.TypeDeclaration.properties.annotations.name) != null) {
            var cNode = node.lowLevel();
            var isPropertyName = universeDef.Universe10.MethodBase.properties.is.name;
            var traitNodes = node.attributes(isPropertyName);
            cNode.preserveAnnotations();
            node.resetChildren();
            if (traitNodes.length != 0) {
                isNode = patchMethodIs(node, traitNodes.map(function (x) { return x.lowLevel(); }).map(function (x) {
                    return {
                        node: x,
                        transformer: x.transformer()
                    };
                }));
            }
        }
        var attrs = node.attrs();
        for (var _i = 0, attrs_1 = attrs; _i < attrs_1.length; _i++) {
            var attr = attrs_1[_i];
            var appended = this.appendUnitIfNeeded(attr, units);
            this.patchReferenceAttr(attr, rootNode, resolver, units);
            this.popUnitIfNeeded(units, appended);
        }
        if (universeHelpers.isTypeDeclarationSibling(node.definition())) {
            var appended = this.appendUnitIfNeeded(node, units);
            this.patchType(node, rootNode, resolver, units);
            this.popUnitIfNeeded(units, appended);
        }
        var childNodes = node.elements();
        for (var _a = 0, childNodes_1 = childNodes; _a < childNodes_1.length; _a++) {
            var ch = childNodes_1[_a];
            var appended = this.appendUnitIfNeeded(ch, units);
            this.patchReferences(ch, rootNode, resolver, units);
            this.popUnitIfNeeded(units, appended);
        }
        if (isNode) {
            isNode.filterChildren();
        }
    };
    ReferencePatcher.prototype.patchReferenceAttr = function (attr, rootNode, resolver, units) {
        var property = attr.property();
        if (!property.range().isAssignableFrom(universeDef.Universe10.Reference.name)) {
            return;
        }
        var value = attr.value();
        if (value == null) {
            return;
        }
        var llNode = attr.lowLevel();
        var transformer = llNode.transformer();
        var isAnnotation = universeHelpers.isAnnotationsProperty(property);
        if (typeof value == "string") {
            var stringToPatch = value;
            if (transformer != null) {
                var actualNode = toOriginal(llNode);
                stringToPatch = actualNode.value();
            }
            if (isAnnotation) {
                stringToPatch = stringToPatch.substring(1, stringToPatch.length - 1);
            }
            var newValue = this.patchTypeName(stringToPatch, rootNode.lowLevel().unit(), units, resolver, transformer, isAnnotation);
            if (newValue != null) {
                if (isAnnotation) {
                    newValue = "(" + newValue + ")";
                }
                attr.lowLevel().setValueOverride(newValue);
            }
        }
        else {
            var sValue = value;
            var key = sValue.lowLevel().key();
            var stringToPatch = key;
            if (transformer != null) {
                var actualNode = toOriginal(sValue.lowLevel());
                stringToPatch = actualNode.key();
            }
            if (key != null) {
                if (isAnnotation) {
                    stringToPatch = stringToPatch.substring(1, stringToPatch.length - 1);
                }
                var newValue = this.patchTypeName(stringToPatch, rootNode.lowLevel().unit(), units, resolver, transformer, isAnnotation);
                if (newValue != null) {
                    if (isAnnotation) {
                        newValue = "(" + newValue + ")";
                    }
                    sValue.lowLevel().setKeyOverride(newValue);
                }
            }
        }
    };
    ReferencePatcher.prototype.patchType = function (node, rootNode, resolver, units) {
        var _this = this;
        if (!node.localType().isExternal()) {
            var rootUnit = rootNode.lowLevel().unit();
            var rootPath = rootUnit.absolutePath();
            //if(rootPath != localPath) {
            var typeAttributes = node.attributes(universeDef.Universe10.TypeDeclaration.properties.type.name);
            for (var _i = 0, typeAttributes_1 = typeAttributes; _i < typeAttributes_1.length; _i++) {
                var typeAttr = typeAttributes_1[_i];
                var localUnit = typeAttr.lowLevel().unit();
                var localPath = localUnit.absolutePath();
                if (localPath == rootPath) {
                    continue;
                }
                var value = typeAttr.value();
                if (typeof value == "string") {
                    var gotExpression = checkExpression(value);
                    var llNode = typeAttr.lowLevel();
                    var transformer = llNode.transformer();
                    var stringToPatch = value;
                    var escapeData = { status: ParametersEscapingStatus.NOT_REQUIRED };
                    var additionalUnits = transformer ? transformer.unitsChain : null;
                    if (transformer != null || value.indexOf("<<") >= 0) {
                        var actualNode = toOriginal(llNode);
                        var actualValue = actualNode.value();
                        escapeData = escapeTemplateParameters(actualValue);
                        if (escapeData.status == ParametersEscapingStatus.OK) {
                            if (gotExpression) {
                                stringToPatch = escapeData.resultingString;
                            }
                            else {
                                stringToPatch = actualValue;
                            }
                        }
                        else {
                            transformer = null;
                        }
                    }
                    var appendedAdditional;
                    if (additionalUnits) {
                        appendedAdditional = [];
                        for (var _a = 0, additionalUnits_1 = additionalUnits; _a < additionalUnits_1.length; _a++) {
                            var u = additionalUnits_1[_a];
                            appendedAdditional.push(this.appendUnitIfNeeded(u, units));
                        }
                    }
                    var appendedAttrUnit = this.appendUnitIfNeeded(typeAttr, units);
                    var newValue;
                    if (gotExpression) {
                        var expressionPatchFailed = false;
                        var expr = typeExpressions.parse(stringToPatch);
                        var gotPatch = false;
                        typeExpressions.visit(expr, function (x) {
                            if (x.type == "name") {
                                var lit = x;
                                var typeName = lit.value;
                                var unescapeData = { status: ParametersEscapingStatus.NOT_REQUIRED };
                                var unescaped;
                                if (escapeData.status == ParametersEscapingStatus.OK) {
                                    unescaped = escapeData.substitutions[typeName];
                                    if (unescaped == null) {
                                        unescapeData = unescapeTemplateParameters(typeName, escapeData.substitutions);
                                        if (unescapeData.status == ParametersEscapingStatus.OK) {
                                            typeName = unescapeData.resultingString;
                                        }
                                        else if (unescapeData.status == ParametersEscapingStatus.ERROR) {
                                            expressionPatchFailed = true;
                                            return;
                                        }
                                    }
                                    else {
                                        typeName = unescaped;
                                    }
                                }
                                if (transformer == null && (unescaped != null || unescapeData.status == ParametersEscapingStatus.OK)) {
                                    lit.value = typeName;
                                    return;
                                }
                                var patched = _this.patchTypeName(typeName, rootUnit, units, resolver, transformer);
                                if (patched != null) {
                                    lit.value = patched;
                                    gotPatch = true;
                                }
                            }
                        });
                        if (gotPatch && !expressionPatchFailed) {
                            newValue = typeExpressions.serializeToString(expr);
                        }
                        else {
                            newValue = value;
                        }
                    }
                    else if (!(escapeData.status == ParametersEscapingStatus.OK && transformer == null)) {
                        newValue = this.patchTypeName(stringToPatch, rootUnit, units, resolver, transformer);
                    }
                    if (newValue != null) {
                        typeAttr.lowLevel().setValueOverride(newValue);
                        typeAttr.overrideValue(null);
                    }
                    this.popUnitIfNeeded(units, appendedAttrUnit);
                    if (appendedAdditional) {
                        for (var _b = 0, _c = appendedAdditional.reverse(); _b < _c.length; _b++) {
                            var ap = _c[_b];
                            this.popUnitIfNeeded(units, ap);
                        }
                    }
                }
                else {
                    var llTypeNode = _.find(node.lowLevel().children(), function (x) { return x.key() == "type"; });
                    if (llTypeNode) {
                        var def = node.definition().universe().type(universeDef.Universe10.TypeDeclaration.name);
                        var newNode = new hlimpl.ASTNodeImpl(llTypeNode, null, def, null);
                        var appended = this.appendUnitIfNeeded(newNode, units);
                        this.patchReferences(newNode, rootNode, resolver, units);
                        this.popUnitIfNeeded(units, appended);
                    }
                }
            }
        }
    };
    ReferencePatcher.prototype.patchTypeName = function (stringToPatch, rootUnit, units, resolver, transformer, isAnnotation) {
        var _this = this;
        if (isAnnotation === void 0) { isAnnotation = false; }
        var newValue;
        if (transformer) {
            if (stringToPatch && stringToPatch.indexOf("<<") >= 0) {
                var doContinue = true;
                var types = rootUnit.highLevel().types();
                newValue = transformer.transform(stringToPatch, true, function () { return doContinue; }, function (val, tr) {
                    var newVal = _this.patchValue(val, rootUnit, resolver, tr.unitsChain);
                    if (newVal == null) {
                        newVal = val;
                    }
                    if (isAnnotation) {
                        if (types.getAnnotationType(newVal) != null) {
                            doContinue = false;
                        }
                    }
                    else if (types.getType(newVal) != null) {
                        doContinue = false;
                    }
                    return newVal;
                }).value;
            }
        }
        if (newValue === undefined) {
            newValue = this.patchValue(stringToPatch, rootUnit, resolver, units);
        }
        return newValue;
    };
    ReferencePatcher.prototype.patchNodeName = function (hlNode, rootUnit, resolver) {
        var llNode = hlNode.lowLevel();
        var key = llNode.key();
        var patched = this.patchValue(key, rootUnit, resolver, [llNode.unit()]);
        if (patched != null) {
            llNode.setKeyOverride(patched);
        }
    };
    ReferencePatcher.prototype.patchValue = function (value, rootUnit, resolver, units) {
        var ind = value.lastIndexOf(".");
        var referencedUnit;
        var plainName;
        if (ind >= 0) {
            var oldNS = value.substring(0, ind);
            plainName = value.substring(ind + 1);
            for (var i = units.length; i > 0; i--) {
                var localUnit = units[i - 1];
                var nsMap = resolver.nsMap(localUnit);
                if (nsMap == null) {
                    continue;
                }
                var info = nsMap[oldNS];
                if (info == null) {
                    continue;
                }
                referencedUnit = info.unit;
                if (referencedUnit != null) {
                    break;
                }
            }
        }
        else {
            if (def.rt.builtInTypes().get(value) != null) {
                return null;
            }
            plainName = value;
            referencedUnit = units[units.length - 1];
        }
        var newNS = resolver.resolveNamespace(rootUnit, referencedUnit);
        if (newNS == null) {
            return null;
        }
        var newValue = newNS + "." + plainName;
        return newValue;
    };
    ReferencePatcher.prototype.patchUses = function (node, resolver) {
        if (!(node instanceof proxy.LowLevelCompositeNode)) {
            return;
        }
        var unit = node.unit();
        var extendedUnitMap = resolver.expandedPathMap(unit);
        if (extendedUnitMap == null) {
            return;
        }
        var unitMap = resolver.pathMap(unit);
        if (!unitMap) {
            unitMap = {};
        }
        var cNode = node;
        var originalChildren = node.children();
        var usesNodes = originalChildren.filter(function (x) {
            return x.key() == universeDef.Universe10.FragmentDeclaration.properties.uses.name;
        });
        var oNode = toOriginal(node);
        var yamlNode = oNode;
        while (yamlNode instanceof proxy.LowLevelProxyNode) {
            yamlNode = yamlNode.originalNode();
        }
        var usesInfos = Object.keys(unitMap).map(function (x) { return extendedUnitMap[x]; });
        var extendedUsesInfos = Object.keys(extendedUnitMap).map(function (x) { return extendedUnitMap[x]; })
            .filter(function (x) { return !unitMap[x.absolutePath()]; } /*&&this.usedNamespaces[x.namespace()]*/ /*&&this.usedNamespaces[x.namespace()]*/);
        var u = node.unit();
        var unitPath = u.absolutePath();
        var newUses = jsyaml.createMapNode("uses");
        newUses["_parent"] = yamlNode;
        newUses.setUnit(yamlNode.unit());
        for (var _i = 0, _a = usesInfos.concat(extendedUsesInfos); _i < _a.length; _i++) {
            var ui = _a[_i];
            var up = ui.absolutePath();
            var ip = ui.includePath;
            var mapping = jsyaml.createMapping(ui.namespace(), ip);
            mapping.setUnit(yamlNode.unit());
            newUses.addChild(mapping);
        }
        if (usesNodes.length > 0) {
            cNode.replaceChild(usesNodes[0], newUses);
        }
        else {
            cNode.replaceChild(null, newUses);
        }
        while (node instanceof proxy.LowLevelProxyNode) {
            node = node.originalNode();
        }
        //node.actual()["usesNode"] = newUses;
    };
    ReferencePatcher.prototype.removeUses = function (node) {
        if (!(node instanceof proxy.LowLevelCompositeNode)) {
            return;
        }
        var cNode = node;
        var originalChildren = node.children();
        var usesNodes = originalChildren.filter(function (x) {
            return x.key() == universeDef.Universe10.FragmentDeclaration.properties.uses.name;
        });
        if (usesNodes.length > 0) {
            cNode.removeChild(usesNodes[0]);
        }
    };
    ReferencePatcher.prototype.resetTypes = function (hlNode) {
        for (var _i = 0, _a = hlNode.elements(); _i < _a.length; _i++) {
            var ch = _a[_i];
            this.resetTypes(ch);
        }
        delete hlNode.lowLevel().actual().types;
        delete hlNode["_ptype"];
        delete hlNode["_types"];
        hlNode.setAssociatedType(null);
    };
    ;
    ReferencePatcher.prototype.appendUnitIfNeeded = function (node, units) {
        if (node instanceof jsyaml.CompilationUnit) {
            var unit = node;
            if (unit.absolutePath() != units[units.length - 1].absolutePath()) {
                units.push(unit);
                return true;
            }
            return false;
        }
        var originalNode = toOriginal(node.lowLevel());
        var originalUnit = originalNode.unit();
        if (originalNode.valueKind() == yaml.Kind.INCLUDE_REF) {
            var ref = originalNode.includePath();
            var includedUnit = originalUnit.resolve(ref);
            units.push(includedUnit);
            return true;
        }
        else {
            if (originalUnit.absolutePath() != units[units.length - 1].absolutePath()) {
                units.push(originalUnit);
                return true;
            }
            return false;
        }
    };
    ReferencePatcher.prototype.popUnitIfNeeded = function (units, appended) {
        if (appended) {
            units.pop();
        }
    };
    return ReferencePatcher;
}());
exports.ReferencePatcher = ReferencePatcher;
var ParametersEscapingStatus;
(function (ParametersEscapingStatus) {
    ParametersEscapingStatus[ParametersEscapingStatus["OK"] = 0] = "OK";
    ParametersEscapingStatus[ParametersEscapingStatus["NOT_REQUIRED"] = 1] = "NOT_REQUIRED";
    ParametersEscapingStatus[ParametersEscapingStatus["ERROR"] = 2] = "ERROR";
})(ParametersEscapingStatus || (ParametersEscapingStatus = {}));
var PARAM_OCCURENCE_STR = "__P_A_R_A_M_E_T_E_R__";
function escapeTemplateParameters(str) {
    if (str == null || typeof str != "string") {
        return { status: ParametersEscapingStatus.NOT_REQUIRED };
    }
    var resultingString = "";
    var map = {};
    var prev = 0;
    for (var i = str.indexOf("<<"); i >= 0; i = str.indexOf("<<", prev)) {
        resultingString += str.substring(prev, i);
        prev = str.indexOf(">>", i);
        if (prev < 0) {
            return { status: ParametersEscapingStatus.ERROR };
        }
        prev += ">>".length;
        var paramStr = str.substring(i, prev);
        var substitution = PARAM_OCCURENCE_STR + i + PARAM_OCCURENCE_STR;
        map[substitution] = paramStr;
        resultingString += substitution;
    }
    if (resultingString.length == 0) {
        return { status: ParametersEscapingStatus.NOT_REQUIRED };
    }
    resultingString += str.substring(prev, str.length);
    return {
        resultingString: resultingString,
        substitutions: map,
        status: ParametersEscapingStatus.OK
    };
}
function unescapeTemplateParameters(str, substitutions) {
    if (str == null) {
        return { status: ParametersEscapingStatus.NOT_REQUIRED };
    }
    var resultingString = "";
    var prev = 0;
    for (var i = str.indexOf(PARAM_OCCURENCE_STR); i >= 0; i = str.indexOf(PARAM_OCCURENCE_STR, prev)) {
        prev = str.indexOf(PARAM_OCCURENCE_STR, i + 1);
        prev += PARAM_OCCURENCE_STR.length;
        if (prev < 0) {
            return { status: ParametersEscapingStatus.ERROR };
        }
        var substitution = str.substring(i, prev);
        var originalParamOccurence = substitutions[substitution];
        if (originalParamOccurence == null) {
            return { status: ParametersEscapingStatus.ERROR };
        }
        resultingString += originalParamOccurence;
    }
    if (resultingString.length == 0) {
        return { status: ParametersEscapingStatus.NOT_REQUIRED };
    }
    resultingString += str.substring(prev, str.length);
    return {
        resultingString: resultingString,
        substitutions: substitutions,
        status: ParametersEscapingStatus.OK
    };
}
function checkExpression(value) {
    var gotExpression = false;
    for (var i = 0; i < value.length; i++) {
        var ch = value.charAt(i);
        if (ch == "|" || ch == "(" || ch == "[") {
            gotExpression = true;
            break;
        }
    }
    return gotExpression;
}
;
function patchMethodIs(node, traits) {
    var llMethod = node.lowLevel();
    var ramlVersion = node.definition().universe().version();
    var originalLlMethod = toOriginal(llMethod);
    var isPropertyName = universeDef.Universe10.MethodBase.properties.is.name;
    var isNode = _.find(llMethod.children(), function (x) { return x.key() == isPropertyName; });
    if (isNode == null) {
        var newLLIsNode = new jsyaml.ASTNode(yaml.newMapping(yaml.newScalar(isPropertyName), yaml.newItems()), originalLlMethod.unit(), originalLlMethod, null, null);
        isNode = llMethod.replaceChild(null, newLLIsNode);
    }
    var originalIsNode = _.find(originalLlMethod.children(), function (x) { return x.key() == isPropertyName; });
    var childrenToPreserve = originalIsNode != null ? originalIsNode.children() : [];
    var newTraits = childrenToPreserve.concat(traits.map(function (x) {
        var llChNode = prepareTraitRefNode(x.node, isNode);
        var cNode = new proxy.LowLevelCompositeNode(llChNode, isNode, x.transformer, ramlVersion);
        return cNode;
    }));
    isNode.setChildren(newTraits);
    isNode.filterChildren();
    return isNode;
}
exports.patchMethodIs = patchMethodIs;
function prepareTraitRefNode(llNode, llParent) {
    llParent = toOriginal(llParent);
    llNode = toOriginal(llNode);
    var yNode = llNode.actual();
    if (llNode.key() == universeDef.Universe10.MethodBase.properties.is.name) {
        yNode = llNode.yamlNode().value;
    }
    if (yNode.kind == yaml.Kind.SEQ) {
        yNode = yNode.items[0];
    }
    var result = new jsyaml.ASTNode(yNode, llNode.unit(), llParent, null, null);
    return result;
}
exports.prepareTraitRefNode = prepareTraitRefNode;
function toOriginal(node) {
    for (var i = 0; i < 2 && node instanceof proxy.LowLevelProxyNode; i++) {
        node = node.originalNode();
    }
    return node;
}
//# sourceMappingURL=referencePatcher.js.map