"use strict";
var ts = require("typescript");
var tsm = require("./tsASTMatchers");
var path = require("path");
var fs = require("fs");
var tsStructureParser = require("./tsStructureParser");
var ns = { 'RamlWrapper': true };
var HelperMethod = (function () {
    function HelperMethod(originalName, wrapperMethodName, returnType, args, meta) {
        this.originalName = originalName;
        this.wrapperMethodName = wrapperMethodName;
        this.returnType = returnType;
        this.args = args;
        this.meta = meta;
    }
    HelperMethod.prototype.targetWrappers = function () {
        var isValid = true;
        var result = [];
        this.args.forEach(function (x) {
            var arr = flatten(x.type, ns);
            if (arr.length == 0) {
                return;
            }
            if (!isValid || result.length != 0) {
                result = [];
                isValid = false;
                return;
            }
            result = result.concat(arr);
        });
        return result;
    };
    HelperMethod.prototype.callArgs = function () {
        return this.args.map(function (x) {
            if (flatten(x.type, ns).length == 0) {
                return x;
            }
            return {
                name: "this",
                type: null
            };
        });
    };
    return HelperMethod;
}());
exports.HelperMethod = HelperMethod;
function getHelperMethods(srcPath) {
    var result = [];
    var content = fs.readFileSync(path.resolve(srcPath)).toString();
    var mod = ts.createSourceFile("sample.ts", content, ts.ScriptTarget.ES3, true);
    tsm.Matching.visit(mod, function (x) {
        var node = x;
        if (node.kind == ts.SyntaxKind.FunctionDeclaration) {
            var meta = getMeta(node, content);
            if (!meta) {
                return;
            }
            var originalName = node.name.text;
            var wrapperMethodName = originalName;
            if (meta.name) {
                wrapperMethodName = meta.name;
            }
            else {
                meta.name = originalName;
            }
            var wrapperMethodName = meta.name ? meta.name : originalName;
            var args = node.parameters ? node.parameters.map(function (a) { return readArg(a, srcPath); }) : [];
            var override = meta.override ? meta.override : false;
            var returnType = tsStructureParser.buildType(node.type, srcPath);
            result.push(new HelperMethod(originalName, wrapperMethodName, returnType, args, meta));
        }
    });
    return result;
}
exports.getHelperMethods = getHelperMethods;
var refineComment = function (comment) {
    return comment.replace(/^\s*\/\*+/g, '').replace(/\*+\/\s*$/g, '').split('\n')
        .map(function (x) { return x.replace(/^\s*\/\//g, '').replace(/^\s*\* {0,1}/g, ''); }).join('\n').trim();
};
function getMeta(node, content) {
    var cRange = ts.getLeadingCommentRanges(content, node.pos);
    if (!cRange) {
        return null;
    }
    var comment = cRange.map(function (x) { return content.substring(x.pos, x.end); }).join('\n');
    var ind = comment.indexOf('__$helperMethod__');
    if (ind < 0) {
        return null;
    }
    ind += '__$helperMethod__'.length;
    var indMeta = comment.indexOf('__$meta__');
    if (indMeta < 0) {
        return { comment: refineComment(comment.substring(ind)) };
    }
    var commentStr = refineComment(comment.substring(ind, indMeta));
    var indMetaObj = comment.indexOf('{', indMeta);
    if (indMetaObj < 0) {
        return { comment: commentStr };
    }
    try {
        var meta = JSON.parse(refineComment(comment.substring(indMetaObj)));
        meta.comment = commentStr.trim().length > 0 ? commentStr : null;
        meta.override = meta.override || false;
        meta.primary = meta.primary || false;
        meta.deprecated = meta.deprecated || false;
        return meta;
    }
    catch (e) {
        console.log(e);
    }
    return {};
}
function readArg(node, srcPath) {
    var name = node.name.text;
    var type = tsStructureParser.buildType(node.type, srcPath);
    return {
        name: name,
        type: type
    };
}
function flatten(t, namespaces) {
    if (t.typeKind == tsStructureParser.TypeKind.ARRAY) {
        if (namespaces) {
            return [];
        }
        else {
            return [flatten(t.base)[0] + '[]'];
        }
    }
    else if (t.typeKind == tsStructureParser.TypeKind.BASIC) {
        var bt = t;
        var str = bt.basicName;
        var nameSpace = bt.nameSpace && bt.nameSpace.trim();
        if (nameSpace != null && nameSpace.length > 0 && nameSpace != "RamlWrapper") {
            str = nameSpace + "." + str;
        }
        if (bt.typeArguments && bt.typeArguments.length != 0) {
            str += "<" + bt.typeArguments.map(function (x) { return flatten(x); }).join(', ') + ">";
        }
        if (namespaces) {
            if (bt.nameSpace) {
                return namespaces[bt.nameSpace] ? [str] : [];
            }
            else {
                return [];
            }
        }
        return [str];
    }
    else if (t.typeKind == tsStructureParser.TypeKind.UNION) {
        var ut = t;
        var result = [];
        ut.options.forEach(function (x) { return result = result.concat(flatten(x, namespaces)); });
        return result;
    }
    return [];
}
exports.flatten = flatten;
//# sourceMappingURL=helperMethodExtractor.js.map