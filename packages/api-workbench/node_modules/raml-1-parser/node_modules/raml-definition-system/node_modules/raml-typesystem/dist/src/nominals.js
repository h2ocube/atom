"use strict";
var ts = require("./typesystem");
var nt = require("./nominal-types");
var parse = require("./parse");
var restrictions = require("./restrictions");
var NOMINAL = "nominal";
var pc;
function setPropertyConstructor(p) {
    pc = p;
}
exports.setPropertyConstructor = setPropertyConstructor;
function toNominal(t, callback, customizer) {
    if (customizer === void 0) { customizer = null; }
    var vs = null;
    if (t.getExtra(NOMINAL)) {
        return t.getExtra(NOMINAL);
    }
    //if (t.isEmpty()){
    //    if (t.superTypes().length==1){
    //        return toNominal(t.superTypes()[0],callback);
    //    }
    //}
    if (!t) {
        var res = callback("any");
        if (!res) {
            vs = new nt.StructuredType(t.name());
        }
    }
    if (t.isBuiltin()) {
        var s = (t.name() != "any" && t.name() != "array") ? callback(t.name()) : null;
        if (!s) {
            if (t.isScalar()) {
                vs = new nt.ValueType(t.name(), null);
            }
            else {
                vs = new nt.StructuredType(t.name());
            }
        }
        else {
            vs = s;
        }
    }
    else {
        if (t.isObject()) {
            vs = new nt.StructuredType(t.name(), null);
        }
        else if (t.isArray()) {
            var ar = new nt.Array(t.name(), null);
            vs = ar;
            t.putExtra(NOMINAL, vs);
            var cm = t.oneMeta(restrictions.ComponentShouldBeOfType);
            var r = cm ? cm.value() : ts.ANY;
            ar.setComponent(toNominal(r, callback));
        }
        else if (t instanceof ts.UnionType) {
            var ut = new nt.Union(t.name(), null);
            if (t.superTypes().length == 0) {
                ut._superTypes.push(toNominal(ts.UNION, callback, customizer));
            }
            t.putExtra(NOMINAL, ut);
            t.options().forEach(function (x) {
                if (ut.left == null) {
                    ut.left = toNominal(x, callback);
                }
                else if (ut.right == null) {
                    ut.right = toNominal(x, callback);
                }
                else {
                    var nu = new nt.Union(t.name(), null);
                    nu.left = ut.right;
                    nu.right = toNominal(x, callback);
                    ut.right = nu;
                }
            });
            vs = ut;
        }
        else if (t.isScalar()) {
            vs = new nt.ValueType(t.name(), null);
        }
        else if (t instanceof ts.ExternalType) {
            var e = t;
            var et = new nt.ExternalType(e.name());
            et.schemaString = e.schema();
            vs = et;
        }
    }
    if (!vs) {
        vs = new nt.StructuredType(t.name());
    }
    t.superTypes().forEach(function (x) {
        var mn = toNominal(x, callback);
        if (x.isBuiltin()) {
            vs._superTypes.push(mn);
        }
        else {
            vs.addSuperType(mn);
        }
    });
    if (t.isEmpty()) {
        if (t.isArray() && t.superTypes().length == 1 && t.superTypes()[0].isAnonymous()) {
            var q = vs.superTypes()[0];
            q.setName(t.name());
            q._subTypes = q._subTypes.filter(function (x) { return x != vs; });
            vs = q;
        }
        if (t.isUnion() && t.superTypes().length == 1 && t.superTypes()[0].isAnonymous()) {
            var q = vs.superTypes()[0];
            q.setName(t.name());
            q._subTypes = q._subTypes.filter(function (x) { return x != vs; });
            vs = q;
        }
    }
    t.putExtra(NOMINAL, vs);
    var proto = parse.toProto(t);
    proto.properties.forEach(function (x) {
        var prop = pc ? pc(x.id) : new nt.Property(x.id);
        prop.withDomain(vs);
        prop.withRange(toNominal(x.type, callback));
        if (!x.optional) {
            prop.withRequired(true);
        }
    });
    proto.facetDeclarations.forEach(function (x) {
        var prop = pc ? pc(x.facetName()) : new nt.Property(x.facetName());
        prop.withRange(toNominal(x.type(), callback));
        vs.addFacet(prop);
    });
    t.customFacets().forEach(function (x) {
        vs.fixFacet(x.facetName(), x.value());
    });
    var basicFacets = t.metaOfType(restrictions.FacetRestriction);
    for (var _i = 0, basicFacets_1 = basicFacets; _i < basicFacets_1.length; _i++) {
        var x = basicFacets_1[_i];
        vs.fixFacet(x.facetName(), x.value());
    }
    vs.addAdapter(t);
    if (t.isEmpty()) {
        vs.addAdapter(new nt.Empty());
    }
    vs._validator = function (x) { return t.validate(x, false).getErrors(); };
    if (t.isBuiltin()) {
        vs.buildIn = true;
    }
    else {
        t.subTypes().forEach(function (x) {
            var ns = toNominal(x, callback, customizer);
        });
    }
    return vs;
}
exports.toNominal = toNominal;
//# sourceMappingURL=nominals.js.map