"use strict";
/// <reference path="../typings/main.d.ts" />
var _ = require("./utils");
var xmlValidator = require('./xmlUtil');
var DOMParser = require('xmldom').DOMParser;
var ZSchema = require("z-schema");
var ValidationResult = (function () {
    function ValidationResult() {
    }
    return ValidationResult;
}());
exports.ValidationResult = ValidationResult;
var useLint = true;
var ErrorsCache = (function () {
    function ErrorsCache() {
        this.errors = {};
    }
    ErrorsCache.prototype.getValue = function (key) {
        return this.errors[key];
    };
    ErrorsCache.prototype.setValue = function (key, value) {
        this.errors[key] = value;
    };
    return ErrorsCache;
}());
var globalCache = new ErrorsCache();
global.cleanCache = function () {
    globalCache = new ErrorsCache();
};
var DummyProvider = (function () {
    function DummyProvider() {
    }
    DummyProvider.prototype.contextPath = function () {
        return "";
    };
    DummyProvider.prototype.normalizePath = function (url) {
        return "";
    };
    DummyProvider.prototype.content = function (reference) {
        return "";
    };
    DummyProvider.prototype.hasAsyncRequests = function () {
        return false;
    };
    DummyProvider.prototype.resolvePath = function (context, relativePath) {
        return "";
    };
    DummyProvider.prototype.isAbsolutePath = function (uri) {
        return false;
    };
    DummyProvider.prototype.contentAsync = function (reference) {
        var _this = this;
        return {
            then: function (arg) { return arg(_this.content(reference)); },
            resolve: function () { return null; }
        };
    };
    DummyProvider.prototype.promiseResolve = function (arg) {
        return {
            then: function (arg1) { return arg1(arg); },
            resolve: function () { return null; }
        };
    };
    return DummyProvider;
}());
var exampleKey = function (content, schema, contextPath) {
    return "__EXAMPLE_" + content + schema + contextPath;
};
var JSONSchemaObject = (function () {
    function JSONSchemaObject(schema, provider) {
        this.schema = schema;
        this.provider = provider;
        if (!provider) {
            this.provider = new DummyProvider();
        }
        else {
            this.provider = provider;
        }
        if (!schema || schema.trim().length == 0 || schema.trim().charAt(0) != '{') {
            throw new Error("Invalid JSON schema content");
        }
        var jsonSchemaObject;
        try {
            var jsonSchemaObject = JSON.parse(schema);
        }
        catch (err) {
            throw new Error("It is not JSON schema(can not parse JSON:" + err.message + ")");
        }
        if (!jsonSchemaObject) {
            return;
        }
        try {
            var api = require('json-schema-compatibility');
            this.setupId(jsonSchemaObject, this.provider.contextPath());
            var schemaVer = "" + jsonSchemaObject["$schema"];
            if (schemaVer.indexOf("http://json-schema.org/draft-04/") == -1) {
                jsonSchemaObject = api.v4(jsonSchemaObject);
            }
            else {
                this.fixRequired(jsonSchemaObject);
            }
        }
        catch (e) {
            throw new Error('Can not parse schema' + schema);
        }
        delete jsonSchemaObject['$schema'];
        this.jsonSchema = jsonSchemaObject;
    }
    JSONSchemaObject.prototype.fixRequired = function (obj) {
        // Object.keys(obj).forEach(x=>{
        //     var val=obj[x];
        //     if (x==="required"){
        //         if (typeof val==="string"){
        //             obj[x]=[val];
        //         }
        //     }
        //     if (x==="properties"||x==="items"||x==="additionalItems"||x==="patternProperties"){
        //         this.fixRequired(val);
        //     }
        //
        // })
    };
    JSONSchemaObject.prototype.getType = function () {
        return "source.json";
    };
    JSONSchemaObject.prototype.validateObject = function (object) {
        //TODO Validation of objects
        //xmlutil(content);
        this.validate(JSON.stringify(object));
    };
    JSONSchemaObject.prototype.getMissingReferences = function (references, normalize) {
        var _this = this;
        if (normalize === void 0) { normalize = false; }
        var result = [];
        var validator = new ZSchema();
        references.forEach(function (references) { return validator.setRemoteReference(references.reference, references.content || {}); });
        var schemaUrl = null;
        if (this.jsonSchema.id && typeof (this.jsonSchema.id) === "string") {
            schemaUrl = this.jsonSchema.id;
            var innerPos = schemaUrl.indexOf("#");
            if (innerPos != -1) {
                schemaUrl = schemaUrl.substr(0, innerPos);
            }
        }
        try {
            validator.validateSchema(this.jsonSchema);
        }
        catch (Error) {
            //we should never be exploding here, instead we'll report this error later
            return [];
        }
        var result = validator.getMissingRemoteReferences();
        var filteredReferences = [];
        if (result)
            filteredReferences = _.filter(result, function (referenceUrl) {
                return validator.cache[referenceUrl] == null && referenceUrl != schemaUrl;
            });
        return normalize ? filteredReferences.map(function (reference) { return _this.provider.normalizePath(reference); }) : filteredReferences;
    };
    JSONSchemaObject.prototype.getSchemaPath = function (schema, normalize) {
        if (normalize === void 0) { normalize = false; }
        if (!schema) {
            return "";
        }
        if (!schema.id) {
            return "";
        }
        var id = schema.id.trim();
        if (!(id.lastIndexOf('#') === id.length - 1)) {
            return id;
        }
        var result = id.substr(0, id.length - 1);
        if (!normalize) {
            return result;
        }
        return this.provider.normalizePath(result);
    };
    JSONSchemaObject.prototype.patchSchema = function (schema) {
        var _this = this;
        if (!schema) {
            return schema;
        }
        if (!schema.id) {
            return schema;
        }
        var id = schema.id.trim();
        if (!(id.lastIndexOf('#') === id.length - 1)) {
            id = id + '#';
            schema.id = id;
        }
        ;
        var currentPath = id.substr(0, id.length - 1);
        if (!this.provider.isAbsolutePath(currentPath)) {
            return schema;
        }
        currentPath = this.provider.normalizePath(currentPath);
        var refContainers = [];
        this.collectRefContainers(schema, refContainers);
        refContainers.forEach(function (refConatiner) {
            var reference = refConatiner['$ref'];
            if (typeof reference !== 'string') {
                return;
            }
            if (reference.indexOf('#') === 0) {
                return;
            }
            if (reference.indexOf('#') === -1) {
                reference = reference + '#';
            }
            var resolvedRef = _this.provider.resolvePath(currentPath, reference);
            refConatiner['$ref'] = resolvedRef;
        });
    };
    JSONSchemaObject.prototype.collectRefContainers = function (rootObject, refContainers) {
        var _this = this;
        Object.keys(rootObject).forEach(function (key) {
            if (key === '$ref') {
                refContainers.push(rootObject);
                return;
            }
            if (!rootObject[key]) {
                return;
            }
            if (typeof rootObject[key] === 'object') {
                _this.collectRefContainers(rootObject[key], refContainers);
            }
        });
    };
    JSONSchemaObject.prototype.validate = function (content, alreadyAccepted) {
        var _this = this;
        if (alreadyAccepted === void 0) { alreadyAccepted = []; }
        var key = exampleKey(content, this.schema, this.provider.contextPath());
        var error = globalCache.getValue(key);
        if (error) {
            if (error instanceof Error) {
                throw error;
            }
            return;
        }
        var validator = new ZSchema();
        alreadyAccepted.forEach(function (accepted) { return validator.setRemoteReference(accepted.reference, accepted.content); });
        validator.validate(JSON.parse(content), this.jsonSchema);
        var missingReferences = validator.getMissingRemoteReferences().filter(function (reference) { return !_.find(alreadyAccepted, function (acceptedReference) { return reference === acceptedReference.reference; }); });
        if (!missingReferences || missingReferences.length === 0) {
            this.acceptErrors(key, validator.getLastErrors(), true);
            return;
        }
        var acceptedReferences = [];
        missingReferences.forEach(function (reference) {
            var remoteSchemeContent;
            var result = { reference: reference };
            try {
                var api = require('json-schema-compatibility');
                var jsonObject = JSON.parse(_this.provider.content(reference));
                _this.setupId(jsonObject, _this.provider.normalizePath(reference));
                remoteSchemeContent = api.v4(jsonObject);
                delete remoteSchemeContent['$schema'];
                result.content = remoteSchemeContent;
            }
            catch (exception) {
                result.error = exception;
            }
            finally {
                acceptedReferences.push(result);
            }
        });
        if (this.provider.hasAsyncRequests()) {
            return;
        }
        acceptedReferences.forEach(function (accepted) {
            alreadyAccepted.push(accepted);
        });
        this.validate(content, alreadyAccepted);
    };
    JSONSchemaObject.prototype.setupId = function (json, path) {
        if (!path) {
            return;
        }
        if (!json) {
            return;
        }
        if (json.id) {
            json.id = json.id.trim();
            if (json.id.indexOf('#') < 0) {
                json.id = json.id + '#';
            }
            return;
        }
        json.id = path.replace(/\\/g, '/') + '#';
        this.patchSchema(json);
    };
    JSONSchemaObject.prototype.acceptErrors = function (key, errors, throwImmediately) {
        if (throwImmediately === void 0) { throwImmediately = false; }
        if (errors && errors.length > 0) {
            var res = new Error("Content is not valid according to schema:" + errors.map(function (x) { return x.message + " " + x.params; }).join(", "));
            res.errors = errors;
            globalCache.setValue(key, res);
            if (throwImmediately) {
                throw res;
            }
            return;
        }
        globalCache.setValue(key, 1);
    };
    JSONSchemaObject.prototype.contentAsync = function (reference) {
        var _this = this;
        var remoteSchemeContent;
        var api = require('json-schema-compatibility');
        var contentPromise = this.provider.contentAsync(reference);
        if (!contentPromise) {
            return this.provider.promiseResolve({
                reference: reference,
                content: null,
                error: new Error('Reference not found: ' + reference)
            });
        }
        var result = contentPromise.then(function (cnt) {
            var content = { reference: reference };
            try {
                var jsonObject = JSON.parse(cnt);
                _this.setupId(jsonObject, _this.provider.normalizePath(reference));
                remoteSchemeContent = api.v4(jsonObject);
                delete remoteSchemeContent['$schema'];
                content.content = remoteSchemeContent;
            }
            catch (exception) {
                content.error = exception;
            }
            return content;
        });
        return result;
    };
    return JSONSchemaObject;
}());
exports.JSONSchemaObject = JSONSchemaObject;
var MAX_EXAMPLES_TRESHOLD = 10;
var XMLSchemaObject = (function () {
    function XMLSchemaObject(schema) {
        this.schema = schema;
        this.extraElementData = null;
        this.contentToResult = {};
        if (schema.charAt(0) != '<') {
            throw new Error("Invalid JSON schema");
        }
        this.schemaObj = new xmlValidator.XMLValidator(this.handleReferenceElement(schema));
    }
    XMLSchemaObject.prototype.getType = function () {
        return "text.xml";
    };
    XMLSchemaObject.prototype.validateObject = function (object) {
        if (this.extraElementData) {
            var objectName = Object.keys(object)[0];
            if (!this.extraElementData.type && !this.extraElementData.originalName) {
                this.acceptErrors("key", [new Error('Referenced type "' + this.extraElementData.requestedName + '" is not match with "' + objectName + '" root node')], true);
                return;
            }
            if (this.extraElementData.originalName && objectName !== this.extraElementData.originalName) {
                this.acceptErrors("key", [new Error('Referenced type "' + this.extraElementData.requestedName + '" is not match with "' + objectName + '" root node')], true);
                return;
            }
            if (this.extraElementData.type) {
                var root = object[objectName];
                delete object[objectName];
                object[this.extraElementData.name] = root;
            }
        }
        this.validate(xmlValidator.jsonToXml(object));
    };
    XMLSchemaObject.prototype.validate = function (xml) {
        try {
            var rs = this.contentToResult[xml];
            if (rs === false) {
                return;
            }
            if (rs) {
                throw rs;
            }
            var validationErrors = this.schemaObj.validate(xml);
            this.acceptErrors("key", validationErrors, true);
            this.contentToResult[xml] = false;
            if (Object.keys(this.contentToResult).length > MAX_EXAMPLES_TRESHOLD) {
                this.contentToResult = {};
            }
        }
        catch (e) {
            this.contentToResult[xml] = e;
            throw e;
        }
    };
    XMLSchemaObject.prototype.handleReferenceElement = function (content) {
        var doc = new DOMParser().parseFromString(content);
        var schema = elementChildrenByName(doc, 'xs:schema')[0];
        var elements = elementChildrenByName(schema, 'xs:element');
        var element = _.find(elements, function (element) { return element.getAttribute('extraelement') === 'true'; });
        if (!element) {
            return content;
        }
        var extraElementData = {};
        extraElementData.name = element.getAttribute('name');
        extraElementData.type = element.getAttribute('type');
        extraElementData.originalName = element.getAttribute('originalname');
        extraElementData.requestedName = element.getAttribute('requestedname');
        if (!extraElementData.type) {
            schema.removeChild(element);
        }
        element.removeAttribute('originalname');
        element.removeAttribute('requestedname');
        element.removeAttribute('extraelement');
        this.extraElementData = extraElementData;
        return doc.toString();
    };
    XMLSchemaObject.prototype.acceptErrors = function (key, errors, throwImmediately) {
        if (throwImmediately === void 0) { throwImmediately = false; }
        if (errors && errors.length > 0) {
            var res = new Error("Content is not valid according to schema:" + errors.map(function (x) { return x.message; }).join(", "));
            res.errors = errors;
            globalCache.setValue(key, res);
            if (throwImmediately) {
                throw res;
            }
            return;
        }
    };
    return XMLSchemaObject;
}());
exports.XMLSchemaObject = XMLSchemaObject;
function getJSONSchema(content, provider) {
    var key = schemaKey(provider, content);
    var rs = useLint ? globalCache.getValue(key) : false;
    if (rs && rs.provider) {
        return rs;
    }
    var res = new JSONSchemaObject(content, provider);
    globalCache.setValue(key, res);
    return res;
}
exports.getJSONSchema = getJSONSchema;
var schemaKey = function (provider, content) {
    var contextPath = "";
    if (provider) {
        contextPath = provider.contextPath();
    }
    var key = "__SCHEMA_" + content + contextPath;
    return key;
};
function getXMLSchema(content, provider) {
    var key = schemaKey(provider, content);
    var rs = useLint ? globalCache.getValue(content) : false;
    if (rs) {
        return rs;
    }
    var res = new XMLSchemaObject(content);
    if (useLint) {
        globalCache.setValue(content, res);
    }
    return res;
}
exports.getXMLSchema = getXMLSchema;
function createSchema(content, provider) {
    var key = schemaKey(provider, content);
    var rs = useLint ? globalCache.getValue(key) : false;
    if (rs) {
        return rs;
    }
    try {
        var res = new JSONSchemaObject(content, provider);
        if (useLint) {
            globalCache.setValue(key, res);
        }
        return res;
    }
    catch (e) {
        try {
            var res = new XMLSchemaObject(content);
            if (useLint) {
                globalCache.setValue(key, res);
            }
            return res;
        }
        catch (e) {
            if (useLint) {
                globalCache.setValue(key, new Error("Can not parse schema"));
            }
            return null;
        }
    }
}
exports.createSchema = createSchema;
function elementChildrenByName(parent, tagName) {
    var elements = parent.getElementsByTagName(tagName);
    var result = [];
    for (var i = 0; i < elements.length; i++) {
        var child = elements[i];
        if (child.parentNode === parent) {
            result.push(child);
        }
    }
    return result;
}
//# sourceMappingURL=schemaUtil.js.map