"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ts = require("./typesystem");
var tsInterfaces = require("./typesystem-interfaces");
var rs = require("./restrictions");
var typesystem_1 = require("./typesystem");
var typeExpressions = require("./typeExpressions");
var facetR = require("./facetRegistry");
var meta = require("./metainfo");
var metainfo_1 = require("./metainfo");
var typesystem_2 = require("./typesystem");
var restrictions_1 = require("./restrictions");
var restrictions_2 = require("./restrictions");
(function (NodeKind) {
    NodeKind[NodeKind["SCALAR"] = 0] = "SCALAR";
    NodeKind[NodeKind["ARRAY"] = 1] = "ARRAY";
    NodeKind[NodeKind["MAP"] = 2] = "MAP";
})(exports.NodeKind || (exports.NodeKind = {}));
var NodeKind = exports.NodeKind;
var JSObjectNode = (function () {
    function JSObjectNode(_key, obj, inArr, provider) {
        if (inArr === void 0) { inArr = false; }
        this._key = _key;
        this.obj = obj;
        this.inArr = inArr;
        this.provider = provider;
    }
    JSObjectNode.prototype.value = function () {
        return this.obj;
    };
    JSObjectNode.prototype.key = function () {
        if (!this._key) {
            if (this.kind() === NodeKind.MAP && this.inArr) {
                var l = Object.keys(this.obj);
                if (l.length === 1) {
                    return l[0];
                }
            }
        }
        return this._key;
    };
    JSObjectNode.prototype.childWithKey = function (k) {
        if (this.obj == null) {
            return null;
        }
        if (this.obj.hasOwnProperty(k)) {
            return new JSObjectNode(k, this.obj[k], false, this.contentProvider());
        }
        return null;
    };
    JSObjectNode.prototype.children = function () {
        var _this = this;
        if (Array.isArray(this.obj)) {
            return this.obj.map(function (x) { return new JSObjectNode(null, x, true, _this.contentProvider()); });
        }
        else if (this.obj && typeof this.obj == "object") {
            return Object.keys(this.obj).map(function (x) { return new JSObjectNode(x, _this.obj[x], false, _this.provider); });
        }
        return [];
    };
    JSObjectNode.prototype.kind = function () {
        if (!this.obj) {
            return NodeKind.SCALAR;
        }
        if (Array.isArray(this.obj)) {
            return NodeKind.ARRAY;
        }
        else if (typeof this.obj === "object") {
            return NodeKind.MAP;
        }
        return NodeKind.SCALAR;
    };
    JSObjectNode.prototype.contentProvider = function () {
        return this.provider;
    };
    ;
    return JSObjectNode;
}());
function parseJSON(name, n, r, provider) {
    if (r === void 0) { r = ts.builtInRegistry(); }
    return parse(name, new JSObjectNode(null, n, false, provider), r);
}
exports.parseJSON = parseJSON;
function parseJSONTypeCollection(n, r, provider) {
    if (r === void 0) { r = ts.builtInRegistry(); }
    return parseTypeCollection(new JSObjectNode(null, n, false, provider), r);
}
exports.parseJSONTypeCollection = parseJSONTypeCollection;
function endsWithQuestionMark(p) {
    return p.charAt(p.length - 1) == '?';
}
var PropertyBean = (function () {
    function PropertyBean() {
    }
    PropertyBean.prototype.add = function (t) {
        if (!this.optional && !this.additonal && !this.regExp && !this.type.isSubTypeOf(ts.NIL)) {
            t.addMeta(new rs.HasProperty(this.id));
        }
        var matchesPropertyFacet;
        if (this.additonal) {
            matchesPropertyFacet = new rs.AdditionalPropertyIs(this.type);
        }
        else if (this.regExp) {
            matchesPropertyFacet = new rs.MapPropertyIs(this.id, this.type);
        }
        else {
            matchesPropertyFacet = new rs.PropertyIs(this.id, this.type, this.optional);
        }
        if (matchesPropertyFacet != null) {
            t.addMeta(matchesPropertyFacet);
            if (this.type instanceof ts.InheritedType && this.type.name() == null) {
                //Linking anonymous types with properties declaring them
                this.type.setContextMeta(matchesPropertyFacet);
            }
        }
    };
    return PropertyBean;
}());
exports.PropertyBean = PropertyBean;
var TypeCollection = (function () {
    function TypeCollection() {
        this._types = [];
        this._typeMap = {};
        this.uses = {};
        this._annotationTypes = [];
        this._annotationTypeMap = {};
    }
    TypeCollection.prototype.library = function (n) {
        return this.uses[n];
    };
    TypeCollection.prototype.addLibrary = function (n, t) {
        this.uses[n] = t;
    };
    TypeCollection.prototype.add = function (t) {
        this._types.push(t);
        this._typeMap[t.name()] = t;
    };
    TypeCollection.prototype.getType = function (name) {
        if (this._typeMap.hasOwnProperty(name)) {
            return this._typeMap[name];
        }
        return null;
    };
    TypeCollection.prototype.addAnnotationType = function (t) {
        this._annotationTypes.push(t);
        this._annotationTypeMap[t.name()] = t;
    };
    TypeCollection.prototype.getAnnotationType = function (name) {
        if (this._annotationTypeMap.hasOwnProperty(name)) {
            return this._annotationTypeMap[name];
        }
        return null;
    };
    TypeCollection.prototype.types = function () {
        return this._types;
    };
    TypeCollection.prototype.annotationTypes = function () {
        return this._annotationTypes;
    };
    TypeCollection.prototype.getAnnotationTypeRegistry = function () {
        var _this = this;
        var r = new typesystem_2.TypeRegistry(ts.builtInRegistry());
        this.annotationTypes().forEach(function (x) { return r.addType(x); });
        Object.keys(this.uses).forEach(function (x) {
            _this.uses[x].annotationTypes().forEach(function (y) { return r.put(x + "." + y.name(), y); });
        });
        return r;
    };
    TypeCollection.prototype.getTypeRegistry = function () {
        var _this = this;
        var r = new typesystem_2.TypeRegistry(ts.builtInRegistry());
        this.types().forEach(function (x) { return r.addType(x); });
        Object.keys(this.uses).forEach(function (x) {
            _this.uses[x].types().forEach(function (y) { return r.put(x + "." + y.name(), y); });
        });
        return r;
    };
    return TypeCollection;
}());
exports.TypeCollection = TypeCollection;
var AccumulatingRegistry = (function (_super) {
    __extends(AccumulatingRegistry, _super);
    function AccumulatingRegistry(toParse, schemas, ts, _c) {
        _super.call(this, ts);
        this.toParse = toParse;
        this.schemas = schemas;
        this._c = _c;
        this.parsing = {};
    }
    AccumulatingRegistry.prototype.get = function (name) {
        var result = _super.prototype.get.call(this, name);
        if (!result) {
            var chld = this.toParse ? this.toParse.childWithKey(name) : null;
            if (!chld) {
                chld = this.schemas ? this.schemas.childWithKey(name) : null;
            }
            if (chld) {
                if (this.parsing[name]) {
                    return ts.derive(name, [ts.RECURRENT]);
                }
                this.parsing[name] = true;
                try {
                    var tp = parse(name, chld, this);
                }
                finally {
                    delete this.parsing[name];
                }
                return tp;
            }
            else {
                var dt = name.indexOf('.');
                if (dt != -1) {
                    var ln = name.substring(0, dt);
                    var tn = name.substr(dt + 1);
                    var lib = this._c.library(ln);
                    if (lib) {
                        var t = lib.getType(tn);
                        if (t) {
                            return t;
                        }
                    }
                }
            }
        }
        return result;
    };
    return AccumulatingRegistry;
}(ts.TypeRegistry));
exports.AccumulatingRegistry = AccumulatingRegistry;
function parseTypes(n, tr) {
    if (tr === void 0) { tr = ts.builtInRegistry(); }
    var provider = n.provider && n.provider();
    return parseTypeCollection(new JSObjectNode(null, n, false, provider), tr);
}
exports.parseTypes = parseTypes;
var WrapArrayNode = (function () {
    function WrapArrayNode(n) {
        this.n = n;
    }
    WrapArrayNode.prototype.key = function () {
        return null;
    };
    WrapArrayNode.prototype.value = function () {
        return null;
    };
    WrapArrayNode.prototype.childWithKey = function (k) {
        var r = this.children();
        for (var i = 0; i < r.length; i++) {
            if (r[i].key() == k) {
                return r[i];
            }
        }
        return null;
    };
    WrapArrayNode.prototype.children = function () {
        return this.n.children().map(function (x) {
            var c = x.children();
            if (c.length == 1) {
                return c[0];
            }
            return x;
        });
    };
    WrapArrayNode.prototype.kind = function () {
        return NodeKind.MAP;
    };
    return WrapArrayNode;
}());
function transformToArray(n) {
    return new WrapArrayNode(n);
}
function parseTypeCollection(n, tr) {
    var result = new TypeCollection();
    if (n.anchor) {
        if (n.anchor().__$$) {
            return n.anchor().__$$;
        }
        n.anchor().__$$ = result;
    }
    var uses = n.childWithKey("uses");
    if (uses && uses.kind() === NodeKind.ARRAY) {
        uses = transformToArray(uses);
    }
    if (uses && uses.kind() === NodeKind.MAP) {
        uses.children().forEach(function (c) {
            result.addLibrary(c.key(), parseTypeCollection(c, tr));
        });
    }
    var tpes = n.childWithKey("types");
    if (tpes && tpes.kind() === NodeKind.ARRAY) {
        tpes = transformToArray(tpes);
    }
    var schemas = n.childWithKey("schemas");
    if (schemas && schemas.kind() === NodeKind.ARRAY) {
        schemas = transformToArray(schemas);
    }
    var reg = new AccumulatingRegistry(tpes, schemas, tr, result);
    if (tpes && tpes.kind() !== NodeKind.SCALAR) {
        tpes.children().forEach(function (x) {
            reg.get(x.key());
        });
    }
    if (schemas && schemas.kind() !== NodeKind.SCALAR) {
        schemas.children().forEach(function (x) {
            reg.get(x.key());
        });
    }
    reg.types().forEach(function (x) { return result.add(x); });
    var tpes = n.childWithKey("annotationTypes");
    if (tpes && tpes.kind() === NodeKind.ARRAY) {
        tpes = transformToArray(tpes);
    }
    if (tpes != null && tpes.kind() === NodeKind.MAP) {
        tpes.children().forEach(function (x) {
            result.addAnnotationType(parse(x.key(), x, reg, false, true, false));
        });
    }
    return result;
}
exports.parseTypeCollection = parseTypeCollection;
function parsePropertyBean(n, tr) {
    var result = new PropertyBean();
    var hasRequiredFacet = false;
    var rs = n.childWithKey("required");
    if (rs) {
        var rsValue = rs.value();
        if (typeof rsValue == "boolean") {
            hasRequiredFacet = true;
        }
        if (rsValue === false) {
            result.optional = true;
            result.id = n.key();
        }
    }
    var name = n.key();
    if (!hasRequiredFacet && endsWithQuestionMark(n.key())) {
        name = name.substr(0, name.length - 1);
        result.optional = true;
    }
    if (name.length == 0 || name === '/.*/') {
        result.additonal = true;
    }
    else if (name.charAt(0) == '/' && name.charAt(name.length - 1) == '/') {
        name = name.substring(1, name.length - 1);
        result.regExp = true;
    }
    result.type = parse(null, n, tr, false, false, false);
    result.id = name;
    return result;
}
exports.parsePropertyBean = parsePropertyBean;
var TypeProto = (function () {
    function TypeProto() {
    }
    TypeProto.prototype.toJSON = function () {
        var result = {};
        if (this.superTypes && this.superTypes.length > 0) {
            if (this.superTypes.length == 1) {
                result['type'] = this.superTypes[0];
            }
            else {
                result['type'] = this.superTypes;
            }
        }
        if (this.customFacets) {
            this.customFacets.forEach(function (x) { return result[x.facetName()] = x.value(); });
        }
        if (this.annotations) {
            this.annotations.forEach(function (x) { return result["(" + x.facetName() + ")"] = x.value(); });
        }
        if (this.facetDeclarations && this.facetDeclarations.length > 0) {
            var facets = {};
            this.facetDeclarations.forEach(function (x) {
                var nm = x.facetName();
                if (x.isOptional()) {
                    nm = nm + "?";
                }
                var vl = null;
                if (x.type().isAnonymous()) {
                    if (x.type().isEmpty()) {
                        vl = typeToSignature(x.type());
                    }
                    else {
                        vl = toProto(x.type()).toJSON();
                    }
                }
                else {
                    vl = typeToSignature(x.type());
                }
                facets[nm] = vl;
            });
            result['facets'] = facets;
        }
        if (this.properties && this.properties.length > 0) {
            var properties = {};
            this.properties.forEach(function (x) {
                var nm = x.id;
                if (x.optional) {
                    nm = nm + "?";
                }
                if (x.additonal) {
                    nm = "/.*/";
                }
                if (x.regExp) {
                    nm = "/" + nm + "/";
                }
                var vl = null;
                if (x.type.isAnonymous()) {
                    if (x.type.isEmpty()) {
                        vl = typeToSignature(x.type);
                    }
                    else {
                        vl = toProto(x.type).toJSON();
                    }
                }
                else {
                    vl = typeToSignature(x.type);
                }
                properties[nm] = vl;
            });
            result['properties'] = properties;
        }
        if (this.basicFacets) {
            this.basicFacets.forEach(function (x) {
                result[x.facetName()] = x.value();
            });
        }
        if (Object.keys(result).length == 1 && !this.notAScalar) {
            if (result['type']) {
                return result['type'];
            }
        }
        if (this.additionalProperties !== undefined) {
            result["additionalProperties"] = this.additionalProperties;
        }
        return result;
    };
    return TypeProto;
}());
exports.TypeProto = TypeProto;
function toProto(type) {
    var result = new TypeProto();
    result.name = type.name();
    result.superTypes = type.superTypes().map(function (x) { return typeToSignature(x); });
    result.annotations = [];
    result.customFacets = [];
    result.facetDeclarations = [];
    result.basicFacets = [];
    result.properties = [];
    var pmap = {};
    type.declaredMeta().forEach(function (x) {
        if (x instanceof meta.Annotation) {
            result.annotations.push(x);
        }
        else if (x instanceof meta.CustomFacet) {
            result.customFacets.push(x);
        }
        else if (x instanceof meta.NotScalar) {
            result.notAScalar = true;
        }
        else if (x instanceof metainfo_1.FacetDeclaration) {
            result.facetDeclarations.push(x);
        }
        else {
            if (x instanceof rs.HasProperty) {
                if (pmap.hasOwnProperty(x.value())) {
                    pmap[x.value()].optional = false;
                }
                else {
                    var pbean = new PropertyBean();
                    pbean.optional = false;
                    pbean.id = x.value();
                    pbean.type = ts.ANY;
                    pmap[x.value()] = pbean;
                }
            }
            else if (x instanceof rs.AdditionalPropertyIs) {
                var pbean = new PropertyBean();
                pbean.optional = false;
                pbean.id = "/.*/";
                pbean.additonal = true;
                pbean.type = x.value();
                pmap['/.*/'] = pbean;
            }
            else if (x instanceof rs.MapPropertyIs) {
                var pbean = new PropertyBean();
                pbean.optional = false;
                pbean.id = x.regexpValue();
                pbean.regExp = true;
                pbean.type = x.value();
                pmap[x.regexpValue()] = pbean;
            }
            else if (x instanceof rs.PropertyIs) {
                if (pmap.hasOwnProperty(x.propertyName())) {
                    pmap[x.propertyName()].type = x.value();
                }
                else {
                    var pbean = new PropertyBean();
                    pbean.optional = true;
                    pbean.id = x.propertyName();
                    pbean.type = x.value();
                    pmap[x.propertyName()] = pbean;
                }
            }
            else if (x instanceof rs.KnownPropertyRestriction) {
                result.additionalProperties = x.value();
            }
            else {
                result.basicFacets.push(x);
            }
        }
    });
    Object.keys(pmap).forEach(function (x) { return result.properties.push(pmap[x]); });
    return result;
}
exports.toProto = toProto;
/***
 * stores a type to JSON structure
 * @param ts
 */
function storeAsJSON(ts) {
    if (ts instanceof typesystem_1.AbstractType) {
        return toProto(ts).toJSON();
    }
    else {
        return storeTypeCollection(ts);
    }
}
exports.storeAsJSON = storeAsJSON;
function storeTypeCollection(tc) {
    var res = {};
    var types = {};
    tc.types().forEach(function (x) {
        types[x.name()] = storeAsJSON(x);
    });
    if (Object.keys(types).length > 0) {
        res["types"] = types;
    }
    var types = {};
    tc.annotationTypes().forEach(function (x) {
        types[x.name()] = storeAsJSON(x);
    });
    if (Object.keys(types).length > 0) {
        res["annotationTypes"] = types;
    }
    return res;
}
function typeToSignature(t) {
    if (t.isAnonymous()) {
        if (t.isArray()) {
            var ci = t.oneMeta(rs.ComponentShouldBeOfType);
            if (ci) {
                var vl = ci.value();
                if (vl.isAnonymous() && vl.isUnion()) {
                    return "(" + typeToSignature(vl) + ")" + "[]";
                }
                return typeToSignature(vl) + "[]";
            }
        }
        if (t.isUnion()) {
            return t.options().map(function (x) { return typeToSignature(x); }).join(" | ");
        }
        return t.superTypes().map(function (x) { return typeToSignature(x); }).join(" , ");
    }
    return t.name();
}
/**
 * parses a type from a JSON structure
 * @param name
 * @param n
 * @param r
 * @returns {any}
 */
function parse(name, n, r, defaultsToAny, annotation, global, ignoreTypeAttr) {
    //Build super types.
    if (r === void 0) { r = ts.builtInRegistry(); }
    if (defaultsToAny === void 0) { defaultsToAny = false; }
    if (annotation === void 0) { annotation = false; }
    if (global === void 0) { global = true; }
    if (ignoreTypeAttr === void 0) { ignoreTypeAttr = false; }
    var provider = n.contentProvider ? n.contentProvider() : null;
    if (n.kind() == NodeKind.SCALAR) {
        var valString = n.value();
        var sp;
        if (valString == null || valString == "Null" || valString == "NULL") {
            sp = ts.STRING;
        }
        else {
            sp = typeExpressions.parseToType("" + valString, r, provider);
        }
        if (name == null) {
            return sp;
        }
        var res = ts.derive(name, [sp]);
        if (r instanceof AccumulatingRegistry) {
            r.addType(res);
            res.putExtra(tsInterfaces.TOP_LEVEL_EXTRA, true);
        }
        return res;
    }
    if (n.kind() == NodeKind.ARRAY) {
        var supers = [];
        n.children().forEach(function (x) {
            supers.push(typeExpressions.parseToType("" + x.value(), r, provider));
        });
        var res = ts.derive(name, supers);
        if (r instanceof AccumulatingRegistry) {
            r.addType(res);
            res.putExtra(tsInterfaces.TOP_LEVEL_EXTRA, true);
        }
        return res;
    }
    var superTypes = [];
    var tp = n.childWithKey("type");
    var shAndType = false;
    if (!tp) {
        tp = n.childWithKey("schema");
    }
    else {
        if (n.childWithKey("schema")) {
            shAndType = true;
        }
    }
    if (!tp || ignoreTypeAttr) {
        if (defaultsToAny) {
            if (n.childWithKey("properties")) {
                superTypes = [ts.OBJECT];
            }
            else {
                superTypes = [ts.ANY];
            }
        }
        else {
            if (n.childWithKey("properties")) {
                superTypes = [ts.OBJECT];
            }
            else {
                superTypes = [ts.STRING];
            }
        }
    }
    else {
        if (tp.kind() == NodeKind.SCALAR) {
            var valString = tp.value();
            if (valString == null || valString == "Null" || valString == "NULL") {
                superTypes = [ts.STRING];
            }
            else {
                superTypes = [typeExpressions.parseToType("" + valString, r, provider)];
            }
        }
        else if (tp.kind() == NodeKind.ARRAY) {
            superTypes = tp.children().map(function (x) { return x.value(); }).map(function (y) { return typeExpressions.parseToType("" + y, r, provider); });
        }
        else if (tp.kind() == NodeKind.MAP) {
            superTypes = [parse("", tp, r, false, false, false)];
        }
    }
    var result = ts.derive(name, superTypes);
    var actualResult = result;
    if (r instanceof AccumulatingRegistry) {
        r.addType(actualResult);
        actualResult.putExtra(tsInterfaces.TOP_LEVEL_EXTRA, true);
    }
    var hasfacetsOrOtherStuffDoesNotAllowedInExternals = null;
    n.children().forEach(function (x) {
        var key = x.key();
        if (!key) {
            return;
        }
        if (key === "type") {
            return;
        }
        if (key === "uses") {
            //FIXME this should be handled depending from parse level
            return;
        }
        if (key === "schema") {
            return;
        }
        if (key == "properties" || key == "additionalProperties") {
            if (result.isSubTypeOf(ts.OBJECT)) {
                return;
            }
        }
        if (key == "items") {
            if (result.isSubTypeOf(ts.ARRAY)) {
                var tp = parse(null, x, r, false, false, false);
                actualResult.addMeta(new restrictions_1.ComponentShouldBeOfType(tp));
                actualResult.putExtra(tsInterfaces.HAS_ITEMS, true);
                return;
            }
        }
        if (key === "facets") {
            hasfacetsOrOtherStuffDoesNotAllowedInExternals = key;
            return;
        }
        if (key == "default" || key == "xml" || key == "required") {
            hasfacetsOrOtherStuffDoesNotAllowedInExternals = key;
        }
        if (key.charAt(0) == '(' && key.charAt(key.length - 1) == ')') {
            result.addMeta(new meta.Annotation(key.substr(1, key.length - 2), x.value()));
            return;
        }
        var vl = facetR.getInstance().buildFacet(key, x.value());
        if (vl /*&&result.isSubTypeOf(vl.requiredType())*/) {
            vl.setNode(x);
            result.addMeta(vl);
        }
        else {
            if (annotation && key === "allowedTargets") {
                result.addMeta(new meta.AllowedTargets(x.value()));
            }
            else {
                var customFacet = new meta.CustomFacet(key, x.value());
                customFacet.setNode(x);
                result.addMeta(customFacet);
            }
        }
    });
    if (result.isSubTypeOf(ts.OBJECT)) {
        var props = n.childWithKey("properties");
        var hasProps = false;
        if (props) {
            if (props.kind() == NodeKind.MAP) {
                props.children().forEach(function (x) {
                    hasProps = true;
                    parsePropertyBean(x, r).add(result);
                });
            }
            else {
                var err = new ts.Status(ts.Status.ERROR, 2, "properties should be a map", actualResult);
                err.setValidationPath({ name: "properties" });
                result.putExtra(tsInterfaces.PARSE_ERROR, err);
            }
        }
        var ap = n.childWithKey("additionalProperties");
        if (ap) {
            result.addMeta(new restrictions_2.KnownPropertyRestriction(ap.value()));
        }
    }
    var props = n.childWithKey("facets");
    if (props) {
        if (props.kind() == NodeKind.MAP) {
            props.children().forEach(function (x) {
                var bean = parsePropertyBean(x, r);
                result.addMeta(new meta.FacetDeclaration(bean.id, bean.type, bean.optional));
            });
        }
        else {
            var err = new ts.Status(ts.Status.ERROR, 2, "facets should be a map", actualResult);
            err.setValidationPath({ name: "facets" });
            result.putExtra(tsInterfaces.PARSE_ERROR, err);
        }
    }
    if (result.isAnonymous() && result.isEmpty()) {
        if (result.superTypes().length == 1) {
            return result.superTypes()[0];
        }
    }
    if (n.kind() != NodeKind.SCALAR) {
        result.addMeta(new meta.NotScalar());
    }
    if (shAndType) {
        actualResult.putExtra(ts.SCHEMA_AND_TYPE, true);
    }
    actualResult.putExtra(ts.GLOBAL, global);
    actualResult.putExtra(ts.SOURCE_EXTRA, n);
    actualResult.putExtra(tsInterfaces.HAS_FACETS, hasfacetsOrOtherStuffDoesNotAllowedInExternals);
    return actualResult;
}
exports.parse = parse;
//# sourceMappingURL=parse.js.map