"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/// <reference path="../typings/main.d.ts" />
var _ = require("underscore");
var su = require("./schemaUtil");
var tsInterfaces = require("./typesystem-interfaces");
var Status = (function () {
    function Status(severity, code, message, source, takeNodeFromSource) {
        if (takeNodeFromSource === void 0) { takeNodeFromSource = false; }
        this.takeNodeFromSource = takeNodeFromSource;
        this.subStatus = [];
        this.severity = severity;
        this.code = code;
        this.message = message;
        this.source = source;
    }
    Status.prototype.getValidationPath = function () {
        return this.vp;
    };
    Status.prototype.getValidationPathAsString = function () {
        if (!this.vp) {
            return "";
        }
        var s = "";
        var c = this.vp;
        while (c) {
            s += c.name;
            if (c.child) {
                s += '/';
            }
            c = c.child;
        }
        return s;
    };
    Status.prototype.patchPath = function (p) {
        if (!p) {
            return null;
        }
        else {
            var c = p;
            var r = null;
            var cp = null;
            while (c) {
                if (!r) {
                    r = { name: c.name };
                    cp = r;
                    c = c.child;
                    cp = r;
                }
                else {
                    var news = { name: c.name };
                    cp.child = news;
                    c = c.child;
                    cp = news;
                }
            }
            return r;
        }
    };
    Status.prototype.setValidationPath = function (c) {
        var _this = this;
        if (this.vp) {
            c = this.patchPath(c);
            var m = c;
            while (m.child) {
                m = m.child;
            }
            m.child = this.vp;
            this.vp = c;
        }
        else {
            this.vp = c;
        }
        this.subStatus.forEach(function (x) {
            x.setValidationPath(_this.vp);
        });
    };
    Status.prototype.addSubStatus = function (st, pathName) {
        if (pathName === void 0) { pathName = null; }
        if (pathName) {
            st.setValidationPath({ name: pathName });
        }
        this.subStatus.push(st);
        if (this.severity < st.severity) {
            this.severity = st.severity;
            this.message = st.message;
        }
    };
    Status.prototype.getErrors = function () {
        if (this.isError() || this.isWarning()) {
            if (this.subStatus.length > 0) {
                var rs = [];
                this.subStatus.forEach(function (x) { return rs = rs.concat(x.getErrors()); });
                return rs;
            }
            return [this];
        }
        return [];
    };
    Status.prototype.getSubStatuses = function () {
        return this.subStatus;
    };
    Status.prototype.getSeverity = function () {
        return this.severity;
    };
    Status.prototype.getMessage = function () {
        return this.message;
    };
    Status.prototype.setMessage = function (message) {
        this.message = message;
    };
    Status.prototype.getSource = function () {
        return this.source;
    };
    Status.prototype.isWarning = function () {
        return this.severity == Status.WARNING;
    };
    Status.prototype.isError = function () {
        return this.severity == Status.ERROR;
    };
    Status.prototype.isOk = function () {
        return this.severity === Status.OK;
    };
    Status.prototype.setSource = function (s) {
        this.source = s;
    };
    Status.prototype.toString = function () {
        if (this.isOk()) {
            return "OK";
        }
        return this.message;
    };
    Status.prototype.getExtra = function (name) {
        if (this.takeNodeFromSource && name == tsInterfaces.SOURCE_EXTRA) {
            if (this.source instanceof TypeInformation) {
                return this.source.node();
            }
        }
        return null;
    };
    Status.prototype.putExtra = function (name, value) { };
    Status.CODE_CONFLICTING_TYPE_KIND = 4;
    Status.ERROR = 3;
    Status.INFO = 1;
    Status.OK = 0;
    Status.WARNING = 2;
    return Status;
}());
exports.Status = Status;
function ok() { return new Status(Status.OK, Status.OK, "", null); }
exports.ok = ok;
;
exports.SCHEMA_AND_TYPE = tsInterfaces.SCHEMA_AND_TYPE_EXTRA;
exports.GLOBAL = tsInterfaces.GLOBAL_EXTRA;
exports.TOPLEVEL = tsInterfaces.TOP_LEVEL_EXTRA;
exports.SOURCE_EXTRA = tsInterfaces.SOURCE_EXTRA;
function error(message, source, takeNodeFromSource) {
    if (takeNodeFromSource === void 0) { takeNodeFromSource = false; }
    return new Status(Status.ERROR, 0, message, source, takeNodeFromSource);
}
exports.error = error;
var TypeInformation = (function () {
    function TypeInformation(_inheritable) {
        this._inheritable = _inheritable;
    }
    TypeInformation.prototype.node = function () {
        return this._node;
    };
    TypeInformation.prototype.setNode = function (node) {
        this._node = node;
    };
    TypeInformation.prototype.owner = function () {
        return this._owner;
    };
    TypeInformation.prototype.isInheritable = function () {
        return this._inheritable;
    };
    TypeInformation.prototype.validateSelf = function (registry) {
        return ok();
    };
    return TypeInformation;
}());
exports.TypeInformation = TypeInformation;
var stack = null;
var Constraint = (function (_super) {
    __extends(Constraint, _super);
    function Constraint() {
        _super.call(this, true);
    }
    Constraint.prototype.intersect = function (t0, t1) {
        var nm = t0.id() + "" + t1.id();
        if (Constraint.intersections.hasOwnProperty(nm)) {
            return Constraint.intersections[nm];
        }
        var is = intersect(nm, [t0, t1]);
        Constraint.intersections[nm] = is;
        return is;
    };
    Constraint.prototype.release = function (t) {
        delete Constraint.intersections[t.name()];
    };
    Constraint.prototype.nothing = function (c, message) {
        if (message === void 0) { message = "Conflicting restrictions"; }
        return new NothingRestrictionWithLocation(stack, message, c);
    };
    /**
     * inner implementation of  compute composed restriction from this and parameter restriction
     * @param restriction
     * @return  composed restriction or null;
     */
    Constraint.prototype.composeWith = function (r) { return null; };
    /**
     * returns optimized restiction or this
     * @returns {Constraint}
     */
    Constraint.prototype.preoptimize = function () {
        if (stack === null) {
            stack = new RestrictionStackEntry(null, null, "top");
        }
        stack = stack.push(this);
        try {
            return this.innerOptimize();
        }
        finally {
            stack = stack.pop();
        }
    };
    Constraint.prototype.innerOptimize = function () {
        return this;
    };
    /**
     * performs attempt to compute composed restriction from this and parameter restriction
     * @param restriction
     * @return  composed restriction or null;
     */
    Constraint.prototype.tryCompose = function (r) {
        if (stack === null) {
            stack = new RestrictionStackEntry(null, null, "top");
        }
        stack = stack.push(this);
        try {
            return this.composeWith(r);
        }
        finally {
            stack = stack.pop();
        }
    };
    Constraint.prototype.kind = function () {
        return tsInterfaces.MetaInformationKind.Constraint;
    };
    Constraint.prototype.conflictMessage = function (otherPath, otherValue) { return null; };
    Constraint.intersections = {};
    return Constraint;
}(TypeInformation));
exports.Constraint = Constraint;
var restr = require("./restrictions");
var metaInfo = require("./metainfo");
var fr = require("./facetRegistry");
var restrictions_1 = require("./restrictions");
var metainfo_1 = require("./metainfo");
var metainfo_2 = require("./metainfo");
var restrictions_2 = require("./restrictions");
var restrictions_3 = require("./restrictions");
var exO = require("./exampleBuilder");
var metainfo_3 = require("./metainfo");
var restrictions_4 = require("./restrictions");
var restrictions_5 = require("./restrictions");
exports.autoCloseFlag = false;
/**
 * Registry of the types
 */
var TypeRegistry = (function () {
    function TypeRegistry(_parent) {
        if (_parent === void 0) { _parent = null; }
        this._parent = _parent;
        this._types = {};
        this.typeList = [];
    }
    TypeRegistry.prototype.put = function (alias, t) {
        this._types[alias] = t;
    };
    TypeRegistry.prototype.addType = function (t) {
        if (t.isAnonymous()) {
            return;
        }
        this._types[t.name()] = t;
        this.typeList.push(t);
    };
    TypeRegistry.prototype.get = function (name) {
        if (this._types.hasOwnProperty(name)) {
            return this._types[name];
        }
        if (this._parent != null) {
            return this._parent.get(name);
        }
        return null;
    };
    TypeRegistry.prototype.types = function () {
        return this.typeList;
    };
    return TypeRegistry;
}());
exports.TypeRegistry = TypeRegistry;
var PropertyCyclesValidator = (function () {
    function PropertyCyclesValidator() {
    }
    PropertyCyclesValidator.prototype.getInfos = function (t) {
        if (t.getExtra("PInfos")) {
            return t.getExtra("PInfos");
        }
        var m = {};
        t.meta().forEach(function (x) {
            if (x instanceof restr.HasProperty) {
                var id = x.value();
                m[id] = { name: id, type: null };
            }
        });
        t.meta().forEach(function (x) {
            if (x instanceof restr.PropertyIs) {
                var id = x.propertyName();
                if (m[id]) {
                    m[id].type = x.value();
                }
            }
        });
        t.putExtra("PInfos", m);
        return m;
    };
    PropertyCyclesValidator.prototype.validate = function (t, visited) {
        var _this = this;
        var i = this.getInfos(t);
        var result = false;
        Object.keys(i).forEach(function (x) {
            result = result || _this.validateInfo(i[x], visited);
        });
        return result;
    };
    PropertyCyclesValidator.prototype.validateInfo = function (t, visited) {
        var _this = this;
        if (visited.some(function (y) { return y == t; })) {
            return true;
        }
        else {
            if (t.type instanceof UnionType) {
                var ut = t.type;
                var passing = true;
                ut.options().forEach(function (o) {
                    if (!_this.validate(o, [t].concat(visited))) {
                        passing = false;
                    }
                });
                return passing;
            }
            if (t.type.isArray()) {
            }
            else {
                return this.validate(t.type, [t].concat(visited));
            }
        }
    };
    PropertyCyclesValidator.prototype.validateType = function (t) {
        var _this = this;
        var i = this.getInfos(t);
        var result = [];
        Object.keys(i).forEach(function (x) {
            if (_this.validateInfo(i[x], [])) {
                result.push(x);
            }
        });
        return result;
    };
    return PropertyCyclesValidator;
}());
var RestrictionsConflict = (function (_super) {
    __extends(RestrictionsConflict, _super);
    function RestrictionsConflict(_conflicting, _stack, source) {
        _super.call(this, Status.ERROR, 0, null, source);
        this._conflicting = _conflicting;
        this._stack = _stack;
        var conflictingMessage = null;
        if (_stack != null) {
            if (_stack.getRestriction() instanceof restr.MinMaxRestriction) {
                var mmr = _stack.getRestriction();
                conflictingMessage = _conflicting.conflictMessage(mmr.facetPath(), mmr.value());
            }
        }
        if (conflictingMessage == null) {
            conflictingMessage = _conflicting + " and " + (_stack != null ? _stack.getRestriction().toString() : "");
        }
        var typeInfo = "";
        if (source instanceof AbstractType) {
            typeInfo = "in type '" + typePath(source) + "'";
        }
        this.message = ("Restrictions conflict " + typeInfo + ": ") + conflictingMessage;
    }
    RestrictionsConflict.prototype.getConflictDescription = function () {
        var rs = "";
        rs += "Restrictions coflict:\n";
        rs += this._stack.getRestriction() + " conflicts with " + this._conflicting + "\n";
        rs += "at\n";
        rs += this._stack.pop();
        return rs;
    };
    RestrictionsConflict.prototype.getConflicting = function () {
        return this._conflicting;
    };
    RestrictionsConflict.prototype.getStack = function () {
        return this._stack;
    };
    RestrictionsConflict.prototype.toRestriction = function () {
        return new NothingRestrictionWithLocation(this._stack, this.message, this._conflicting);
    };
    return RestrictionsConflict;
}(Status));
exports.RestrictionsConflict = RestrictionsConflict;
var globalId = 0;
exports.VALIDATED_TYPE = null;
var AbstractType = (function () {
    function AbstractType(_name) {
        this._name = _name;
        this.metaInfo = [];
        this._subTypes = [];
        this.innerid = globalId++;
        this.extras = {};
        this._locked = false;
    }
    AbstractType.prototype.getExtra = function (name) {
        return this.extras[name];
    };
    AbstractType.prototype.putExtra = function (name, v) {
        this.extras[name] = v;
    };
    AbstractType.prototype.id = function () {
        return this.innerid;
    };
    AbstractType.prototype.knownProperties = function () {
        return this.metaOfType(restrictions_5.MatchesProperty);
    };
    AbstractType.prototype.lock = function () {
        this._locked = true;
    };
    AbstractType.prototype.isLocked = function () {
        return this._locked;
    };
    AbstractType.prototype.allFacets = function () {
        return this.meta();
    };
    AbstractType.prototype.declaredFacets = function () {
        return this.declaredMeta();
    };
    AbstractType.prototype.isSubTypeOf = function (t) {
        return t === exports.ANY || this === t || this.superTypes().some(function (x) { return x.isSubTypeOf(t); });
    };
    AbstractType.prototype.isSuperTypeOf = function (t) {
        return this === t || this.allSubTypes().indexOf(t) != -1;
    };
    AbstractType.prototype.addMeta = function (info) {
        this.metaInfo.push(info);
        info._owner = this;
    };
    AbstractType.prototype.name = function () {
        return this._name;
    };
    AbstractType.prototype.label = function () {
        return this._name;
    };
    /**
     * @return directly known sub types of a given type
     */
    AbstractType.prototype.subTypes = function () {
        return this._subTypes;
    };
    /**
     * @return directly known super types of a given type
     */
    AbstractType.prototype.superTypes = function () {
        return [];
    };
    AbstractType.prototype.validateType = function (tr) {
        var _this = this;
        if (tr === void 0) { tr = builtInRegistry(); }
        var rs = new Status(Status.OK, 0, "", this);
        this.validateHierarchy(rs);
        if (this.getExtra(tsInterfaces.PARSE_ERROR)) {
            rs.addSubStatus(this.getExtra(tsInterfaces.PARSE_ERROR));
        }
        if (rs.isOk()) {
            rs.addSubStatus(this.checkConfluent());
            if (this.isExternal()) {
                var allS = this.allSuperTypes();
                var mma = allS.filter(function (x) { return x instanceof ExternalType; });
                if (this instanceof ExternalType) {
                    mma.push(this);
                }
                mma.forEach(function (x) {
                    if (x.isJSON()) {
                        try {
                            su.getJSONSchema(x.schema(), x.getContentProvider && x.getContentProvider());
                        }
                        catch (e) {
                            rs.addSubStatus(new Status(Status.ERROR, 0, e.message, _this));
                        }
                    }
                });
            }
            if (rs.isOk()) {
                this.superTypes().forEach(function (x) {
                    if (x.isAnonymous()) {
                        rs.addSubStatus(x.validateType(tr));
                    }
                });
            }
        }
        if (this.getExtra(exports.SCHEMA_AND_TYPE)) {
            rs.addSubStatus(new Status(Status.ERROR, 0, "schema and type are mutually exclusive", this));
        }
        if (rs.isOk()) {
            this.validateMeta(tr).getErrors().forEach(function (x) { return rs.addSubStatus(x); });
        }
        //if (this.isPolymorphic()||(this.isUnion())) {
        //    rs.addSubStatus(this.canDoAc());
        //}
        if (this.isObject()) {
            var required = {};
            this.restrictions().forEach(function (x) {
                if (x.owner() != _this) {
                    if (x instanceof restr.HasProperty) {
                        required[x.value()] = true;
                    }
                }
            });
            this.declaredMeta().forEach(function (x) {
                if (x instanceof restr.HasProperty) {
                    delete required[x.value()];
                }
            });
            this.declaredMeta().forEach(function (x) {
                if (x instanceof restr.PropertyIs) {
                    var pr = x;
                    if (required.hasOwnProperty(pr.propertyName())) {
                        rs.addSubStatus(new Status(Status.ERROR, 0, "Can not override required property:" + pr.propertyName() + " to be optional", _this));
                    }
                }
            });
            var propertyCycles = new PropertyCyclesValidator().validateType(this);
            if (propertyCycles.length > 0) {
                propertyCycles.forEach(function (p) {
                    var st = new Status(Status.ERROR, 0, p + "has cyclic dependency", _this);
                    st.setValidationPath({ name: p });
                    rs.addSubStatus(st);
                });
            }
        }
        return rs;
    };
    AbstractType.prototype.validateHierarchy = function (rs) {
        var _this = this;
        if (!this.isAnonymous()) {
            if (this.getExtra(tsInterfaces.TOP_LEVEL_EXTRA) && builtInRegistry().get(this.name())) {
                rs.addSubStatus(new Status(Status.ERROR, 0, "redefining builtin type:" + this.name(), this));
            }
        }
        if (this.isSubTypeOf(exports.RECURRENT)) {
            rs.addSubStatus(new Status(Status.ERROR, 0, "recurrent type definition", this), "type");
        }
        if (this.isSubTypeOf(exports.UNKNOWN)) {
            rs.addSubStatus(new Status(Status.ERROR, 0, "inheriting from unknown type", this), "type");
        }
        if (this.isUnion()) {
            var tf = this.typeFamily();
            if (tf.some(function (x) { return x.isSubTypeOf(exports.RECURRENT); })) {
                rs.addSubStatus(new Status(Status.ERROR, 0, "recurrent type as an option of union type", this), "type");
            }
            if (tf.some(function (x) { return x.isSubTypeOf(exports.UNKNOWN); })) {
                rs.addSubStatus(new Status(Status.ERROR, 0, "unknown type as an option of union type", this), "type");
            }
        }
        if (this.isArray()) {
            var fs_1 = this.familyWithArray();
            var ps = this.getExtra(tsInterfaces.HAS_ITEMS) ? "items" : "type";
            if ((fs_1.indexOf(this) != -1) || fs_1.some(function (x) { return x === exports.RECURRENT; })) {
                rs.addSubStatus(new Status(Status.ERROR, 0, "recurrent array type definition", this), ps);
            }
            else if (fs_1.some(function (x) { return x === exports.UNKNOWN; })) {
                rs.addSubStatus(new Status(Status.ERROR, 0, "referring to unknown type " + this.oneMeta(restrictions_3.ComponentShouldBeOfType).value().name() + " as an array component type", this), ps);
            }
        }
        var supers = this.superTypes();
        var hasExternal = false;
        var hasNotExternal = false;
        if (supers.length > 1) {
            supers.forEach(function (x) {
                if (x.isExternal()) {
                    hasExternal = true;
                }
                else {
                    hasNotExternal = true;
                }
            });
        }
        if (hasExternal && hasNotExternal) {
            rs.addSubStatus(new Status(Status.ERROR, 0, "It is not allowed to mix RAML types with externals", this), "type");
        }
        if (this instanceof UnionType) {
            var ut = this;
            ut.options().forEach(function (x) {
                if (x.isExternal()) {
                    rs.addSubStatus(new Status(Status.ERROR, 0, "It is not allowed to mix RAML types with externals", _this), "type");
                }
            });
        }
        if (this.isExternal()) {
            if (this.getExtra(tsInterfaces.HAS_FACETS)) {
                var fs = new Status(Status.ERROR, 0, "External types can not declare facet '" + this.getExtra(tsInterfaces.HAS_FACETS) + "'", this);
                fs.setValidationPath({ name: this.getExtra(tsInterfaces.HAS_FACETS) });
                rs.addSubStatus(fs);
            }
        }
    };
    ;
    AbstractType.prototype.familyWithArray = function () {
        var ts = this.allSuperTypes();
        var mn = this.oneMeta(restrictions_3.ComponentShouldBeOfType);
        if (mn) {
            var at = mn.value();
            ts = ts.concat(at.familyWithArray());
        }
        return ts;
    };
    AbstractType.prototype.validateMeta = function (tr) {
        var rs = new Status(Status.OK, 0, "", this);
        this.declaredMeta().forEach(function (x) {
            x.validateSelf(tr).getErrors().forEach(function (y) { return rs.addSubStatus(y); });
        });
        this.validateFacets(rs);
        return rs;
    };
    AbstractType.prototype.validateFacets = function (rs) {
        var _this = this;
        var fds = {};
        var super_facets = {};
        var rfds = {};
        this.meta().forEach(function (x) {
            if (x instanceof metainfo_1.FacetDeclaration) {
                var fd = x;
                fds[fd.actualName()] = fd;
                if (!fd.isOptional()) {
                    if (fd.owner() !== _this) {
                        rfds[fd.actualName()] = fd;
                    }
                }
                if (fd.owner() != _this) {
                    super_facets[fd.actualName()] = fd;
                }
            }
        });
        this.declaredMeta().forEach(function (x) {
            if (x instanceof metainfo_1.FacetDeclaration) {
                var fd = x;
                if (fd.owner() == _this) {
                    var an = fd.actualName();
                    if (super_facets.hasOwnProperty(an)) {
                        rs.addSubStatus(new Status(Status.ERROR, 0, "facet :" + an + " can not be overriden", _this));
                    }
                    var fp = fr.getInstance().facetPrototypeWithName(an);
                    if (fp && fp.isApplicable(_this) || an == "type" || fd.facetName() == "properties" || an == "schema" || an == "facets" || an == "uses") {
                        rs.addSubStatus(new Status(Status.ERROR, 0, "built-in facet :" + an + " can not be overriden", _this));
                    }
                    if (an.charAt(0) == '(') {
                        rs.addSubStatus(new Status(Status.ERROR, 0, "facet :" + an + " can not start from '('", _this));
                    }
                }
            }
        });
        var knownPropertySet = {};
        this.meta().forEach(function (x) {
            if (x instanceof restrictions_2.PropertyIs) {
                knownPropertySet[x.propId()] = true;
            }
        });
        this.meta().forEach(function (x) {
            if (x instanceof metainfo_2.CustomFacet) {
                var cd = x;
                if (fds.hasOwnProperty(cd.facetName())) {
                    var ft = fds[cd.facetName()].value();
                    rs.addSubStatus(ft.validateDirect(cd.value(), false, false));
                    delete rfds[cd.facetName()];
                }
                else {
                    var msg = _this.isExternal() ? "'" + cd.facetName() + "' facet is prohibited for external types"
                        : "specifying unknown facet:" + cd.facetName();
                    rs.addSubStatus(new Status(Status.ERROR, 0, msg, cd, true));
                }
            }
            if (x instanceof restrictions_4.MapPropertyIs) {
                var mm = x;
                Object.keys(knownPropertySet).forEach(function (c) {
                    try {
                        if (c.match(mm.regexpValue())) {
                            var regexpText = '/' + mm.regexpValue().toString() + '/';
                            rs.addSubStatus(new Status(Status.WARNING, 0, "pattern property '" + regexpText + "' conflicts with property: " + c, _this));
                        }
                    }
                    catch (e) {
                    }
                });
            }
        });
        if (Object.getOwnPropertyNames(rfds).length > 0) {
            rs.addSubStatus(new Status(Status.ERROR, 0, "missing required facets:" + Object.keys(rfds).join(","), this));
        }
    };
    ;
    AbstractType.prototype.allSuperTypes = function () {
        var rs = [];
        this.fillSuperTypes(rs);
        return rs;
    };
    AbstractType.prototype.fillSuperTypes = function (r) {
        this.superTypes().forEach(function (x) {
            if (!_.contains(r, x)) {
                r.push(x);
                x.fillSuperTypes(r);
            }
        });
    };
    AbstractType.prototype.allSubTypes = function () {
        var rs = [];
        this.fillSubTypes(rs);
        return rs;
    };
    AbstractType.prototype.fillSubTypes = function (r) {
        this.subTypes().forEach(function (x) {
            if (!_.contains(r, x)) {
                r.push(x);
                x.fillSubTypes(r);
            }
        });
    };
    AbstractType.prototype.inherit = function (name) {
        var rs = new InheritedType(name);
        rs.addSuper(this);
        return rs;
    };
    /**
     *
     * @return true if type is an inplace type and has no name
     */
    AbstractType.prototype.isAnonymous = function () {
        return (!this._name) || this._name.length === 0;
    };
    /**
     *
     * @return true if type has no associated meta information of restrictions
     */
    AbstractType.prototype.isEmpty = function () {
        if (this.metaInfo.length > 1) {
            return false;
        }
        return this.metaInfo.filter(function (x) { return !(x instanceof metainfo_3.NotScalar); }).length == 0;
    };
    /**
     *
     * @return true if type is an array or extends from an array
     */
    AbstractType.prototype.isArray = function () {
        return this === exports.ARRAY || this.allSuperTypes().indexOf(exports.ARRAY) != -1;
    };
    AbstractType.prototype.propertySet = function () {
        var rs = [];
        this.meta().forEach(function (x) {
            if (x instanceof restrictions_2.PropertyIs) {
                var p = x;
                rs.push(p.propertyName());
            }
        });
        return _.uniq(rs);
    };
    AbstractType.prototype.checkConfluent = function () {
        if (this.computeConfluent) {
            return ok();
        }
        this.computeConfluent = true;
        try {
            var os = restr.optimize(this.restrictions());
            var ns = _.find(os, function (x) { return x instanceof NothingRestriction; });
            if (ns) {
                var lstack = null;
                var another = null;
                if (ns instanceof NothingRestrictionWithLocation) {
                    var nswl = ns;
                    lstack = nswl.getStack();
                    another = nswl.another();
                }
                var status = new RestrictionsConflict(another, lstack, this);
                return status;
            }
            return ok();
        }
        finally {
            this.computeConfluent = false;
        }
    };
    /**
     *
     * @return true if type is object or inherited from object
     */
    AbstractType.prototype.isObject = function () {
        return this == exports.OBJECT || this.allSuperTypes().indexOf(exports.OBJECT) != -1;
    };
    /**
     *
     * @return true if type is object or inherited from object
     */
    AbstractType.prototype.isExternal = function () {
        return this == exports.EXTERNAL || this.allSuperTypes().indexOf(exports.EXTERNAL) != -1;
    };
    /**
     *
     * @return true if type is an boolean type or extends from boolean
     */
    AbstractType.prototype.isBoolean = function () {
        return this == exports.BOOLEAN || this.allSuperTypes().indexOf(exports.BOOLEAN) != -1;
    };
    /**
     *
     * @return true if type is string or inherited from string
     */
    AbstractType.prototype.isString = function () {
        return this == exports.STRING || this.allSuperTypes().indexOf(exports.STRING) != -1;
    };
    /**
     *
     * @return true if type is number or inherited from number
     */
    AbstractType.prototype.isNumber = function () {
        return this == exports.NUMBER || this.allSuperTypes().indexOf(exports.NUMBER) != -1;
    };
    /**
     *
     * @return true if type is number or inherited from number
     */
    AbstractType.prototype.isFile = function () {
        return this == exports.FILE || this.allSuperTypes().indexOf(exports.FILE) != -1;
    };
    /**
     *
     * @return true if type is scalar or inherited from scalar
     */
    AbstractType.prototype.isScalar = function () {
        return this == exports.SCALAR || this.allSuperTypes().indexOf(exports.SCALAR) != -1;
    };
    /**
     * returns true if this type inherits from one of date related types
     */
    AbstractType.prototype.isDateTime = function () {
        return this == exports.DATETIME || this.allSuperTypes().indexOf(exports.DATETIME) != -1;
    };
    /**
     * returns true if this type inherits from one of date related types
     */
    AbstractType.prototype.isDateOnly = function () {
        return this == exports.DATE_ONLY || this.allSuperTypes().indexOf(exports.DATE_ONLY) != -1;
    };
    /**
     * returns true if this type inherits from one of date related types
     */
    AbstractType.prototype.isTimeOnly = function () {
        return this == exports.TIME_ONLY || this.allSuperTypes().indexOf(exports.TIME_ONLY) != -1;
    };
    /**
     * returns true if this type inherits from one of date related types
     */
    AbstractType.prototype.isInteger = function () {
        return this == exports.INTEGER || this.allSuperTypes().indexOf(exports.INTEGER) != -1;
    };
    /**
     * returns true if this type inherits from one of date related types
     */
    AbstractType.prototype.isDateTimeOnly = function () {
        return this == exports.DATETIME_ONLY || this.allSuperTypes().indexOf(exports.DATETIME_ONLY) != -1;
    };
    /**
     *
     * @return true if type is scalar or inherited from scalar
     */
    AbstractType.prototype.isUnknown = function () {
        return this == exports.UNKNOWN || this.allSuperTypes().indexOf(exports.UNKNOWN) != -1;
    };
    /**
     *
     * @return true if type is scalar or inherited from scalar
     */
    AbstractType.prototype.isRecurrent = function () {
        return this == exports.RECURRENT || this.allSuperTypes().indexOf(exports.RECURRENT) != -1;
    };
    /**
     *
     * @return true if type is an built-in type
     */
    AbstractType.prototype.isBuiltin = function () {
        return this.metaInfo.indexOf(BUILT_IN) != -1;
    };
    AbstractType.prototype.exampleObject = function () {
        return exO.example(this);
    };
    /**
     *
     * @return true if type is an polymorphic type
     */
    AbstractType.prototype.isPolymorphic = function () {
        return this.meta().some(function (x) { return x instanceof Polymorphic; });
    };
    /**
     * @return all restrictions associated with type
     */
    AbstractType.prototype.restrictions = function (forValidation) {
        if (forValidation === void 0) { forValidation = false; }
        if (this.isUnion()) {
            var rs = [];
            this.superTypes().forEach(function (x) {
                rs = rs.concat(x.restrictions());
            });
            rs = rs.concat(this.meta().filter(function (x) { return x instanceof Constraint; }));
            return rs;
        }
        var result = [];
        var generic = null;
        this.meta().forEach(function (x) {
            if (x instanceof Constraint) {
                if (x instanceof GenericTypeOf && forValidation) {
                    if (generic) {
                        return;
                    }
                    generic = x;
                }
                result.push(x);
            }
        });
        return result;
    };
    AbstractType.prototype.customFacets = function () {
        return this.declaredMeta().filter(function (x) { return x instanceof metaInfo.CustomFacet; });
    };
    AbstractType.prototype.allCustomFacets = function () {
        return this.meta().filter(function (x) { return x instanceof metaInfo.CustomFacet; });
    };
    AbstractType.prototype.isUnion = function () {
        var rs = false;
        if (this.isBuiltin()) {
            return false;
        }
        this.allSuperTypes().forEach(function (x) { return rs = rs || x instanceof UnionType; });
        return rs;
    };
    /**
     * return all type information associated with type
     */
    AbstractType.prototype.meta = function () {
        return [].concat(this.metaInfo);
    };
    /**
     * validates object against this type without performing AC
     */
    AbstractType.prototype.validateDirect = function (i, autoClose, nullAllowed, path) {
        var _this = this;
        if (autoClose === void 0) { autoClose = false; }
        if (nullAllowed === void 0) { nullAllowed = true; }
        if (path === void 0) { path = null; }
        var prevValidated = exports.VALIDATED_TYPE;
        try {
            exports.VALIDATED_TYPE = this;
            var result = new Status(Status.OK, 0, "", this);
            if (!nullAllowed && (i === null || i === undefined)) {
                if (!this.nullable) {
                    return error("object is expected", this);
                }
            }
            this.restrictions(true).forEach(function (x) { return result.addSubStatus(x.check(i, path)); });
            if ((autoClose || exports.autoCloseFlag) && this.isObject() && (!this.oneMeta(restrictions_1.KnownPropertyRestriction))) {
                var cp = new restrictions_1.KnownPropertyRestriction(false);
                cp.patchOwner(this);
                cp.check(i).getErrors().forEach(function (x) {
                    var rs = new Status(Status.WARNING, 0, x.getMessage(), _this);
                    rs.setValidationPath(x.getValidationPath());
                    result.addSubStatus(rs);
                });
            }
        }
        finally {
            exports.VALIDATED_TYPE = prevValidated;
        }
        return result;
    };
    AbstractType.prototype.validate = function (i, autoClose, nullAllowed) {
        if (autoClose === void 0) { autoClose = false; }
        if (nullAllowed === void 0) { nullAllowed = true; }
        var g = exports.autoCloseFlag;
        if (!nullAllowed && (i === null || i === undefined)) {
            if (!this.nullable) {
                return error("Null or undefined value is not allowed", this);
            }
        }
        if (autoClose) {
            exports.autoCloseFlag = true;
        }
        try {
            for (var _i = 0, _a = this.subTypes(); _i < _a.length; _i++) {
                var subType = _a[_i];
                var vr = subType.validateDirect(i, autoClose || g);
                if (vr.isOk()) {
                    return vr;
                }
            }
            return this.validateDirect(i, autoClose || g);
        }
        finally {
            exports.autoCloseFlag = g;
        }
    };
    /**
     * declares a pattern property on this type,
     * note if type is not inherited from an object type this will move
     * type to inconsistent state
     * @param name - regexp
     * @param type - type of the property
     * @return
     */
    AbstractType.prototype.declareMapProperty = function (name, type) {
        if (type != null) {
            this.addMeta(new restr.MapPropertyIs(name, type));
        }
        return type;
    };
    /**
     * make this type closed type (no unknown properties any more)
     */
    AbstractType.prototype.closeUnknownProperties = function () {
        this.addMeta(new restrictions_1.KnownPropertyRestriction(false));
    };
    AbstractType.prototype.canDoAc = function () {
        var tf = _.uniq(this.typeFamily());
        var s = new Status(Status.OK, 0, "", this);
        for (var i = 0; i < tf.length; i++) {
            for (var j = 0; j < tf.length; j++) {
                if (i != j) {
                    var t0 = tf[i];
                    var t1 = tf[j];
                    var ed = this.emptyIntersectionOrDiscriminator(t0, t1);
                    s.addSubStatus(ed);
                }
            }
        }
        return s;
    };
    AbstractType.prototype.emptyIntersectionOrDiscriminator = function (t0, t1) {
        if (t1 === t0) {
            return ok();
        }
        if (t1.isScalar() && t0.isScalar()) {
            return ok();
        }
        var it = intersect("", [t0, t1]);
        var innerCheckConfluent = it.checkConfluent();
        if (innerCheckConfluent.isOk()) {
            return this.checkDiscriminator(t0, t1);
        }
        return ok();
    };
    AbstractType.prototype.checkDiscriminator = function (t1, t2) {
        var found = new Status(Status.ERROR, 0, "can not discriminate types " + t1.name() + " and " + t2.name() + " without discriminator", this);
        var oneMeta = t1.oneMeta(metaInfo.Discriminator);
        var anotherMeta = t2.oneMeta(metaInfo.Discriminator);
        if (oneMeta != null && anotherMeta != null && oneMeta.value() === (anotherMeta.value())) {
            var d1 = t1.name();
            var d2 = t2.name();
            var dv1 = t1.oneMeta(metaInfo.DiscriminatorValue);
            if (dv1 != null) {
                d1 = dv1.value();
            }
            var dv2 = t2.oneMeta(metaInfo.DiscriminatorValue);
            if (dv2 != null) {
                d2 = dv2.value();
            }
            if (d1 !== d2) {
                return ok();
            }
            found = new Status(Status.ERROR, 0, "types" + t1.name() + " and " + t2.name() + " have same discriminator value", this);
        }
        return found;
    };
    /**
     * performs automatic classification of the instance
     * @param obj
     * @returns {AbstractType}
     */
    AbstractType.prototype.ac = function (obj) {
        if (!this.isPolymorphic() && !this.isUnion()) {
            return this;
        }
        if (this.isBuiltin()) {
            return this;
        }
        var tf = _.uniq(this.typeFamily());
        if (tf.length == 0) {
            return exports.NOTHING;
        }
        if (this.isScalar()) {
            if (this.isNumber()) {
                if (typeof obj == "number") {
                    return this;
                }
                return exports.NOTHING;
            }
            if (this.isString()) {
                if (typeof obj == "string") {
                    return this;
                }
                return exports.NOTHING;
            }
            if (this.isBoolean()) {
                if (typeof obj == "boolean") {
                    return this;
                }
                return exports.NOTHING;
            }
            return this;
        }
        if (tf.length === 1) {
            return tf[0];
        }
        var options = [];
        tf.forEach(function (x) {
            var ds = x.validateDirect(obj, true);
            if (ds.isOk()) {
                options.push(x);
            }
        });
        var t = this.discriminate(obj, options);
        if (!t) {
            return exports.NOTHING;
        }
        return t;
    };
    /**
     * adds new property declaration to this type, note if type is not inherited from an object type this will move
     * type to inconsistent state
     * @param name - name of the property
     * @param type - type of the property
     * @param optional true if property is optinal
     * @return the type with property (this)
     */
    AbstractType.prototype.declareProperty = function (name, t, optional) {
        if (!optional) {
            this.addMeta(new restr.HasProperty(name));
        }
        if (t != null) {
            this.addMeta(new restr.PropertyIs(name, t));
        }
        return this;
    };
    AbstractType.prototype.discriminate = function (obj, opt) {
        var newOpts = [].concat(opt);
        var opts = [].concat(opt);
        while (newOpts.length > 1) {
            var found = false;
            l2: for (var i = 0; i < opts.length; i++) {
                for (var j = 0; j < opts.length; j++) {
                    var t0 = opts[i];
                    var t1 = opts[j];
                    if (t0 != t1) {
                        var nt = select(obj, t0, t1);
                        if (nt === t0) {
                            opts = opts.filter(function (x) { return x != t1; });
                            found = true;
                            break l2;
                        }
                        else if (nt === t1) {
                            opts = opts.filter(function (x) { return x != t0; });
                            found = true;
                            break l2;
                        }
                        else {
                            opts = opts.filter(function (x) { return x != t0 && x != t1; });
                            found = true;
                            break l2;
                        }
                    }
                }
            }
            newOpts = opts;
        }
        if (newOpts.length == 1) {
            return newOpts[0];
        }
        return null;
    };
    /**
     * return instance of type information of particular class
     * @param clazz
     * @returns {any}
     */
    AbstractType.prototype.oneMeta = function (clazz) {
        return _.find(this.meta(), function (x) { return x instanceof clazz; });
    };
    /**
     * return all instances of meta information of particular class
     * @param clazz
     * @returns {any}
     */
    AbstractType.prototype.metaOfType = function (clazz) {
        return this.meta().filter(function (x) { return x instanceof clazz; });
    };
    AbstractType.prototype.declaredMeta = function () {
        return this.metaInfo;
    };
    AbstractType.prototype.descValue = function () {
        var dv = this.oneMeta(metaInfo.DiscriminatorValue);
        if (dv) {
            return dv.value();
        }
        return this.name();
    };
    AbstractType.prototype.isAbstractOrInternal = function () {
        return this.metaInfo.some(function (x) { return x instanceof Abstract || x instanceof Internal; });
    };
    AbstractType.prototype.typeFamily = function () {
        if (this.isUnion()) {
            var res = [];
            this.allSuperTypes().forEach(function (x) {
                if (x instanceof UnionType) {
                    var opts = x.allOptions();
                    for (var i = 0; i < opts.length; i++) {
                        res = res.concat(opts[i].typeFamily());
                    }
                }
            });
            return _.unique(res);
        }
        var rs = [];
        if (!this.isAbstractOrInternal()) {
            rs.push(this);
        }
        this.allSubTypes().forEach(function (x) {
            if (!x.isAbstractOrInternal()) {
                rs.push(x);
            }
        });
        return _.unique(rs);
    };
    return AbstractType;
}());
exports.AbstractType = AbstractType;
var Modifier = (function (_super) {
    __extends(Modifier, _super);
    function Modifier() {
        _super.apply(this, arguments);
    }
    Modifier.prototype.requiredType = function () {
        return exports.ANY;
    };
    Modifier.prototype.kind = function () {
        return tsInterfaces.MetaInformationKind.Modifier;
    };
    return Modifier;
}(TypeInformation));
exports.Modifier = Modifier;
var Polymorphic = (function (_super) {
    __extends(Polymorphic, _super);
    function Polymorphic() {
        _super.call(this, true);
    }
    Polymorphic.prototype.facetName = function () {
        return "polymorphic";
    };
    Polymorphic.prototype.value = function () {
        return true;
    };
    return Polymorphic;
}(Modifier));
exports.Polymorphic = Polymorphic;
var Abstract = (function (_super) {
    __extends(Abstract, _super);
    function Abstract() {
        _super.call(this, false);
    }
    Abstract.prototype.value = function () {
        return true;
    };
    Abstract.prototype.facetName = function () {
        return "abstract";
    };
    return Abstract;
}(Modifier));
exports.Abstract = Abstract;
var Internal = (function (_super) {
    __extends(Internal, _super);
    function Internal() {
        _super.call(this, false);
    }
    Internal.prototype.facetName = function () {
        return "abstract";
    };
    Internal.prototype.value = function () {
        return true;
    };
    return Internal;
}(Modifier));
exports.Internal = Internal;
var BuiltIn = (function (_super) {
    __extends(BuiltIn, _super);
    function BuiltIn() {
        _super.call(this, false);
    }
    BuiltIn.prototype.facetName = function () {
        return "builtIn";
    };
    BuiltIn.prototype.value = function () {
        return true;
    };
    return BuiltIn;
}(Modifier));
var BUILT_IN = new BuiltIn();
var RootType = (function (_super) {
    __extends(RootType, _super);
    function RootType() {
        _super.apply(this, arguments);
    }
    RootType.prototype.kind = function () {
        return "root";
    };
    return RootType;
}(AbstractType));
exports.RootType = RootType;
var InheritedType = (function (_super) {
    __extends(InheritedType, _super);
    function InheritedType() {
        _super.apply(this, arguments);
        this._superTypes = [];
    }
    InheritedType.prototype.superTypes = function () {
        return this._superTypes;
    };
    InheritedType.prototype.knownProperties = function () {
        var vs = this.metaOfType(restrictions_5.MatchesProperty);
        this.superTypes().forEach(function (x) {
            vs = vs.concat(x.knownProperties());
        });
        return vs;
    };
    InheritedType.prototype.kind = function () {
        return "inherited";
    };
    InheritedType.prototype.meta = function () {
        var _this = this;
        var rs = _super.prototype.meta.call(this);
        var hasKp = false;
        this.superTypes().forEach(function (x) {
            x.meta().forEach(function (m) {
                if (m instanceof restrictions_1.KnownPropertyRestriction) {
                    if (hasKp) {
                        return;
                    }
                    var kp = new restrictions_1.KnownPropertyRestriction(false);
                    kp.patchOwner(_this);
                    rs.push(kp);
                    return;
                }
                if (m.isInheritable()) {
                    rs.push(m);
                }
            });
        });
        return rs;
    };
    InheritedType.prototype.addSuper = function (t) {
        this._superTypes.push(t);
        if (!t.isLocked()) {
            t._subTypes.push(this);
        }
        if (t.nullable) {
            this.nullable = true;
        }
    };
    InheritedType.prototype.label = function () {
        var cmp = this.metaOfType(restrictions_3.ComponentShouldBeOfType);
        if (cmp.length > 0) {
            return cmp[0].value().label() + "[]";
        }
        return _super.prototype.label.call(this);
    };
    InheritedType.prototype.contextMeta = function () {
        return this._contextMeta;
    };
    InheritedType.prototype.setContextMeta = function (contextMeta) {
        this._contextMeta = contextMeta;
    };
    return InheritedType;
}(AbstractType));
exports.InheritedType = InheritedType;
var DerivedType = (function (_super) {
    __extends(DerivedType, _super);
    function DerivedType(name, _options) {
        _super.call(this, name);
        this._options = _options;
    }
    /**
     *
     * @returns all possible options
     */
    DerivedType.prototype.allOptions = function () {
        var _this = this;
        var rs = [];
        this._options.forEach(function (x) {
            if (x.kind() == _this.kind()) {
                rs = rs.concat(x.allOptions());
            }
            else {
                rs.push(x);
            }
        });
        return _.unique(rs);
    };
    DerivedType.prototype.options = function () {
        return this._options;
    };
    return DerivedType;
}(AbstractType));
exports.DerivedType = DerivedType;
var UnionType = (function (_super) {
    __extends(UnionType, _super);
    function UnionType(name, _options) {
        var _this = this;
        _super.call(this, name, _options);
        this.options().forEach(function (x) {
            if (x.nullable) {
                _this.nullable = true;
            }
        });
    }
    UnionType.prototype.kind = function () {
        return "union";
    };
    UnionType.prototype.isSubTypeOf = function (t) {
        var isSubType = true;
        this.allOptions().forEach(function (x) {
            if (!x.isSubTypeOf(t)) {
                isSubType = false;
            }
        });
        return isSubType;
        //return t===ANY||this===t|| this.superTypes().some(x=>x.isSubTypeOf(t));
    };
    UnionType.prototype.validate = function (i) {
        return this.validateDirect(i);
    };
    UnionType.prototype.typeFamily = function () {
        var res = [];
        this.allOptions().forEach(function (x) {
            res = res.concat(x.typeFamily());
        });
        return res;
    };
    UnionType.prototype.knownProperties = function () {
        var vs = this.metaOfType(restrictions_5.MatchesProperty);
        this.options().forEach(function (x) {
            vs = vs.concat(x.knownProperties());
        });
        return vs;
    };
    UnionType.prototype.validateDirect = function (i, autoClose) {
        if (autoClose === void 0) { autoClose = false; }
        var result = new Status(Status.OK, 0, "", this);
        this.restrictions().forEach(function (x) { return result.addSubStatus(x.check(i, null)); });
        return result;
    };
    UnionType.prototype.isUnion = function () {
        return true;
    };
    UnionType.prototype.restrictions = function () {
        return [new OrRestriction(this.allOptions().map(function (x) { return new AndRestriction(x.restrictions()); }), "Union type options do not pass validation", "Union type option does not pass validation")];
    };
    UnionType.prototype.label = function () {
        return this.options().map(function (x) { return x.label(); }).join("|");
    };
    return UnionType;
}(DerivedType));
exports.UnionType = UnionType;
var IntersectionType = (function (_super) {
    __extends(IntersectionType, _super);
    function IntersectionType() {
        _super.apply(this, arguments);
    }
    IntersectionType.prototype.kind = function () {
        return "intersection";
    };
    IntersectionType.prototype.restrictions = function () {
        var rs = [];
        this.allOptions().forEach(function (x) { return rs = rs.concat(x.restrictions()); });
        return [new AndRestriction(rs)];
    };
    IntersectionType.prototype.label = function () {
        return this.options().map(function (x) { return x.label(); }).join("&");
    };
    return IntersectionType;
}(DerivedType));
exports.IntersectionType = IntersectionType;
var registry = new TypeRegistry();
function builtInRegistry() {
    return registry;
}
exports.builtInRegistry = builtInRegistry;
function union(name, t) {
    return new UnionType(name, t);
}
exports.union = union;
function intersect(name, t) {
    return new IntersectionType(name, t);
}
exports.intersect = intersect;
/**
 * allows you to extend a type from other types
 * @param name
 * @param t
 * @returns {InheritedType}
 */
function derive(name, t) {
    var r = new InheritedType(name);
    t.forEach(function (x) { return r.addSuper(x); });
    if (r.isSubTypeOf(exports.NIL)) {
        r.nullable = true;
    }
    return r;
}
exports.derive = derive;
/**
 * this function allows you to quickly derive a new type from object;
 * @param name
 * @returns {InheritedType}
 */
function deriveObjectType(name) {
    return derive(name, [exports.OBJECT]);
}
exports.deriveObjectType = deriveObjectType;
function select(obj, t0, t1) {
    if (t0.isScalar() && t1.isScalar()) {
        if (t0.allSubTypes().indexOf(t1) != -1) {
            return t0;
        }
        if (t1.allSubTypes().indexOf(t0) != -1) {
            return t1;
        }
    }
    var d0 = t0.oneMeta(metaInfo.Discriminator);
    var d1 = t1.oneMeta(metaInfo.Discriminator);
    if (d0 && d1) {
        if (d0.property === d1.property) {
            var v0 = t0.descValue();
            var v1 = t1.descValue();
            if (v0 !== v1) {
                var val = obj[d0.property];
                if (val === v0) {
                    return t0;
                }
                if (val === v1) {
                    return t1;
                }
            }
        }
    }
    return null;
}
var NothingRestriction = (function (_super) {
    __extends(NothingRestriction, _super);
    function NothingRestriction() {
        _super.apply(this, arguments);
    }
    NothingRestriction.prototype.check = function (i) {
        if (i === null || i === undefined) {
            return ok();
        }
        return error("nothing ", this);
    };
    NothingRestriction.prototype.requiredType = function () {
        return exports.ANY;
    };
    NothingRestriction.prototype.facetName = function () {
        return "nothing";
    };
    NothingRestriction.prototype.value = function () {
        return "!!!";
    };
    return NothingRestriction;
}(Constraint));
exports.NothingRestriction = NothingRestriction;
var RestrictionStackEntry = (function () {
    function RestrictionStackEntry(_previous, _restriction, id) {
        this._previous = _previous;
        this._restriction = _restriction;
        this.id = id;
    }
    RestrictionStackEntry.prototype.getRestriction = function () { return this._restriction; };
    RestrictionStackEntry.prototype.pop = function () { return this._previous; };
    RestrictionStackEntry.prototype.push = function (r) {
        return new RestrictionStackEntry(this, r, r.toString());
    };
    return RestrictionStackEntry;
}());
exports.RestrictionStackEntry = RestrictionStackEntry;
var NothingRestrictionWithLocation = (function (_super) {
    __extends(NothingRestrictionWithLocation, _super);
    function NothingRestrictionWithLocation(_entry, _message, _another) {
        _super.call(this);
        this._entry = _entry;
        this._message = _message;
        this._another = _another;
    }
    NothingRestrictionWithLocation.prototype.getMessage = function () { return this._message; };
    NothingRestrictionWithLocation.prototype.getStack = function () { return this._entry; };
    NothingRestrictionWithLocation.prototype.another = function () { return this._another; };
    return NothingRestrictionWithLocation;
}(NothingRestriction));
exports.NothingRestrictionWithLocation = NothingRestrictionWithLocation;
var GenericTypeOf = (function (_super) {
    __extends(GenericTypeOf, _super);
    function GenericTypeOf() {
        _super.apply(this, arguments);
    }
    return GenericTypeOf;
}(Constraint));
exports.GenericTypeOf = GenericTypeOf;
var TypeOfRestriction = (function (_super) {
    __extends(TypeOfRestriction, _super);
    function TypeOfRestriction(val) {
        _super.call(this);
        this.val = val;
    }
    TypeOfRestriction.prototype.check = function (i) {
        var to = typeof i;
        if (i === null || i === undefined) {
            return ok();
        }
        if (Array.isArray(i)) {
            to = "array";
        }
        if (to === this.val) {
            return ok();
        }
        return error(this.val + " is expected", this);
    };
    TypeOfRestriction.prototype.value = function () {
        return this.val;
    };
    TypeOfRestriction.prototype.requiredType = function () {
        return exports.ANY;
    };
    TypeOfRestriction.prototype.facetName = function () {
        return "typeOf";
    };
    TypeOfRestriction.prototype.composeWith = function (r) {
        if (r instanceof TypeOfRestriction) {
            var to = r;
            if (to.val == this.val) {
                return this;
            }
            return this.nothing(r);
        }
        return null;
    };
    TypeOfRestriction.prototype.toString = function () {
        return "should be of type " + this.val;
    };
    return TypeOfRestriction;
}(GenericTypeOf));
exports.TypeOfRestriction = TypeOfRestriction;
function is_int(value) {
    if ((parseFloat(value) == parseInt(value)) && !isNaN(value)) {
        return true;
    }
    else {
        return false;
    }
}
var IntegerRestriction = (function (_super) {
    __extends(IntegerRestriction, _super);
    function IntegerRestriction() {
        _super.call(this);
    }
    IntegerRestriction.prototype.check = function (i) {
        if (typeof i == "number" && is_int(i)) {
            return ok();
        }
        return error("integer is expected", this);
    };
    IntegerRestriction.prototype.requiredType = function () {
        return exports.ANY;
    };
    IntegerRestriction.prototype.value = function () {
        return true;
    };
    IntegerRestriction.prototype.facetName = function () {
        return "should be integer";
    };
    return IntegerRestriction;
}(GenericTypeOf));
exports.IntegerRestriction = IntegerRestriction;
var NullRestriction = (function (_super) {
    __extends(NullRestriction, _super);
    function NullRestriction() {
        _super.call(this);
    }
    NullRestriction.prototype.check = function (i) {
        if (i === null || i == undefined || i === "null") {
            return ok();
        }
        return error("null is expected", this);
    };
    NullRestriction.prototype.requiredType = function () {
        return exports.ANY;
    };
    NullRestriction.prototype.value = function () {
        return true;
    };
    NullRestriction.prototype.facetName = function () {
        return "should be null";
    };
    return NullRestriction;
}(GenericTypeOf));
exports.NullRestriction = NullRestriction;
var ScalarRestriction = (function (_super) {
    __extends(ScalarRestriction, _super);
    function ScalarRestriction() {
        _super.call(this);
    }
    ScalarRestriction.prototype.check = function (i) {
        if (!i) {
            return ok();
        }
        if (typeof i === 'number' || typeof i === 'boolean' || typeof i === 'string') {
            return ok();
        }
        return error("scalar is expected", this);
    };
    ScalarRestriction.prototype.requiredType = function () {
        return exports.ANY;
    };
    ScalarRestriction.prototype.facetName = function () {
        return "should be scalar";
    };
    ScalarRestriction.prototype.value = function () {
        return true;
    };
    return ScalarRestriction;
}(GenericTypeOf));
exports.ScalarRestriction = ScalarRestriction;
var OrRestriction = (function (_super) {
    __extends(OrRestriction, _super);
    function OrRestriction(val, _extraMessage, _extraOptionMessage) {
        _super.call(this);
        this.val = val;
        this._extraMessage = _extraMessage;
        this._extraOptionMessage = _extraOptionMessage;
    }
    OrRestriction.prototype.check = function (i, p) {
        var _this = this;
        var cs = new Status(Status.OK, 0, "", this);
        var results = [];
        for (var j = 0; j < this.val.length; j++) {
            var m = this.val[j].check(i, p);
            if (m.isOk()) {
                return ok();
            }
            results.push(m);
        }
        if (results.length > 0) {
            for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
                var r = results_1[_i];
                var ownerName = null;
                var src = r.getSource();
                if (src instanceof TypeInformation) {
                    var owner = src.owner();
                    if (owner) {
                        ownerName = owner.label();
                    }
                }
                r.getErrors().forEach(function (x) {
                    var msg = x.getMessage();
                    if (ownerName) {
                        msg = ownerName + ": " + msg;
                    }
                    if (_this._extraOptionMessage) {
                        msg = _this._extraOptionMessage + " (" + msg + ")";
                    }
                    x.setMessage(msg);
                    cs.addSubStatus(x);
                });
            }
            if (this._extraMessage) {
                cs.addSubStatus(error(this._extraMessage, this));
            }
        }
        return cs;
    };
    OrRestriction.prototype.value = function () {
        return this.val.map(function (x) { return x.value(); });
    };
    OrRestriction.prototype.requiredType = function () {
        return exports.ANY;
    };
    OrRestriction.prototype.facetName = function () {
        return "or";
    };
    return OrRestriction;
}(Constraint));
exports.OrRestriction = OrRestriction;
var AndRestriction = (function (_super) {
    __extends(AndRestriction, _super);
    function AndRestriction(val) {
        _super.call(this);
        this.val = val;
    }
    AndRestriction.prototype.value = function () {
        return this.val.map(function (x) { return x.value(); });
    };
    AndRestriction.prototype.options = function () {
        return this.val;
    };
    AndRestriction.prototype.check = function (i, p) {
        for (var j = 0; j < this.val.length; j++) {
            var st = this.val[j].check(i, p);
            if (!st.isOk()) {
                return st;
            }
        }
        return ok();
    };
    AndRestriction.prototype.requiredType = function () {
        return exports.ANY;
    };
    AndRestriction.prototype.facetName = function () {
        return "and";
    };
    return AndRestriction;
}(Constraint));
exports.AndRestriction = AndRestriction;
/***
 *
 * lets declare built in types
 */
exports.ANY = new RootType("any");
exports.SCALAR = exports.ANY.inherit("scalar");
exports.OBJECT = exports.ANY.inherit("object");
//export const POLYMORPHIC=OBJECT.inherit("polymorphic");
exports.ARRAY = exports.ANY.inherit("array");
exports.NIL = exports.ANY.inherit("nil");
exports.EXTERNAL = exports.ANY.inherit("external");
exports.NUMBER = exports.SCALAR.inherit("number");
exports.INTEGER = exports.NUMBER.inherit("integer");
exports.BOOLEAN = exports.SCALAR.inherit("boolean");
exports.STRING = exports.SCALAR.inherit("string");
//export const DATE=SCALAR.inherit("date");
exports.DATE_ONLY = exports.SCALAR.inherit("date-only");
exports.TIME_ONLY = exports.SCALAR.inherit("time-only");
exports.DATETIME_ONLY = exports.SCALAR.inherit("datetime-only");
exports.DATETIME = exports.SCALAR.inherit("datetime");
exports.FILE = exports.SCALAR.inherit("file");
exports.NOTHING = new RootType("nothing");
exports.UNION = exports.ANY.inherit("union");
exports.UNKNOWN = exports.NOTHING.inherit("unknown");
exports.RECURRENT = exports.NOTHING.inherit("recurrent");
///
//POLYMORPHIC.addMeta(new Polymorphic())
exports.ANY.addMeta(BUILT_IN);
exports.NIL.addMeta(BUILT_IN);
exports.UNION.addMeta(BUILT_IN);
exports.SCALAR.addMeta(BUILT_IN);
exports.OBJECT.addMeta(BUILT_IN);
exports.ARRAY.addMeta(BUILT_IN);
exports.NUMBER.addMeta(BUILT_IN);
exports.INTEGER.addMeta(BUILT_IN);
exports.BOOLEAN.addMeta(BUILT_IN);
exports.STRING.addMeta(BUILT_IN);
exports.EXTERNAL.addMeta(BUILT_IN);
exports.UNKNOWN.addMeta(BUILT_IN);
exports.RECURRENT.addMeta(BUILT_IN);
exports.DATE_ONLY.addMeta(BUILT_IN);
exports.TIME_ONLY.addMeta(BUILT_IN);
exports.DATETIME_ONLY.addMeta(BUILT_IN);
exports.DATETIME.addMeta(BUILT_IN);
exports.FILE.addMeta(BUILT_IN);
//POLYMORPHIC.addMeta(BUILT_IN);
exports.UNKNOWN.addMeta(BUILT_IN);
exports.UNKNOWN.lock();
exports.RECURRENT.addMeta(BUILT_IN);
exports.RECURRENT.lock();
exports.EXTERNAL.lock();
exports.UNION.lock();
///lets register all types in registry
registry.addType(exports.ANY);
registry.addType(exports.SCALAR);
registry.addType(exports.OBJECT);
registry.addType(exports.ARRAY);
registry.addType(exports.NUMBER);
registry.addType(exports.INTEGER);
registry.addType(exports.BOOLEAN);
registry.addType(exports.NIL);
registry.addType(exports.STRING);
registry.addType(exports.DATE_ONLY);
registry.addType(exports.TIME_ONLY);
registry.addType(exports.DATETIME_ONLY);
registry.addType(exports.DATETIME);
registry.addType(exports.FILE);
//registry.addType(POLYMORPHIC);
exports.NOTHING.addMeta(new NothingRestriction());
exports.NUMBER.addMeta(new TypeOfRestriction("number"));
exports.NUMBER.addMeta(new metainfo_1.FacetDeclaration("format", exports.STRING, true));
exports.BOOLEAN.addMeta(new TypeOfRestriction("boolean"));
exports.OBJECT.addMeta(new TypeOfRestriction("object"));
exports.ARRAY.addMeta(new TypeOfRestriction("array"));
exports.STRING.addMeta(new TypeOfRestriction("string"));
exports.INTEGER.addMeta(new IntegerRestriction());
exports.NIL.addMeta(new NullRestriction());
var dt = require("./datetime");
exports.DATE_ONLY.addMeta(new dt.DateOnlyR());
exports.TIME_ONLY.addMeta(new dt.TimeOnlyR());
exports.DATETIME_ONLY.addMeta(new dt.DateTimeOnlyR());
exports.DATETIME.addMeta(new dt.DateTimeR());
exports.FILE.addMeta(new TypeOfRestriction("string"));
var arrayOfString = exports.ARRAY.inherit("");
arrayOfString.addMeta(new restrictions_3.ComponentShouldBeOfType(exports.STRING));
exports.FILE.addMeta(new metainfo_1.FacetDeclaration("fileTypes", arrayOfString, true));
exports.FILE.addMeta(new metainfo_1.FacetDeclaration("minLength", exports.INTEGER, true));
exports.FILE.addMeta(new metainfo_1.FacetDeclaration("maxLength", exports.INTEGER, true));
exports.DATETIME.addMeta(new metainfo_1.FacetDeclaration("format", exports.STRING, true));
exports.NIL.nullable = true;
exports.SCALAR.addMeta(new ScalarRestriction());
registry.types().forEach(function (x) { return x.lock(); });
var ExternalType = (function (_super) {
    __extends(ExternalType, _super);
    function ExternalType(name, _content, json, provider) {
        _super.call(this, name);
        this._content = _content;
        this.json = json;
        this.provider = provider;
        this.addMeta(new restr.MatchToSchema(_content, provider));
        this.addSuper(exports.EXTERNAL);
    }
    ExternalType.prototype.getContentProvider = function () {
        return this.provider;
    };
    ExternalType.prototype.setContentProvider = function (provider) {
        this.provider = provider;
    };
    ExternalType.prototype.kind = function () {
        return "external";
    };
    ExternalType.prototype.isJSON = function () {
        return this.json;
    };
    ExternalType.prototype.schema = function () {
        return this._content;
    };
    return ExternalType;
}(InheritedType));
exports.ExternalType = ExternalType;
function typePath(t) {
    var arr = [];
    while (t != null) {
        if (t.name() == null) {
            if (t instanceof InheritedType) {
                var contextMeta = t.contextMeta();
                if (contextMeta != null) {
                    arr.push(contextMeta.path());
                    t = contextMeta._owner;
                }
                else {
                    break;
                }
            }
            else {
                break;
            }
        }
        else {
            arr.push(t.name());
            break;
        }
    }
    return arr.reverse();
}
exports.typePath = typePath;
//# sourceMappingURL=typesystem.js.map