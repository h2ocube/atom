/// <reference path="../../typings/main.d.ts" />
import su = require("./schemaUtil");
import tsInterfaces = require("./typesystem-interfaces");
import { ParseNode } from "./parse";
export declare type IValidationPath = tsInterfaces.IValidationPath;
export declare class Status implements tsInterfaces.IStatus {
    private takeNodeFromSource;
    static CODE_CONFLICTING_TYPE_KIND: number;
    static ERROR: number;
    static INFO: number;
    static OK: number;
    static WARNING: number;
    protected code: number;
    protected message: string;
    protected severity: number;
    protected source: any;
    protected subStatus: Status[];
    protected vp: tsInterfaces.IValidationPath;
    getValidationPath(): tsInterfaces.IValidationPath;
    getValidationPathAsString(): string;
    patchPath(p: tsInterfaces.IValidationPath): tsInterfaces.IValidationPath;
    setValidationPath(c: tsInterfaces.IValidationPath): void;
    constructor(severity: number, code: number, message: string, source: any, takeNodeFromSource?: boolean);
    addSubStatus(st: Status, pathName?: string): void;
    getErrors(): Status[];
    getSubStatuses(): Status[];
    getSeverity(): number;
    getMessage(): string;
    setMessage(message: string): void;
    getSource(): any;
    isWarning(): boolean;
    isError(): boolean;
    isOk(): boolean;
    setSource(s: any): void;
    toString(): string;
    getExtra(name: string): any;
    putExtra(name: string, value: any): void;
}
export declare function ok(): Status;
export declare const SCHEMA_AND_TYPE: string;
export declare const GLOBAL: string;
export declare const TOPLEVEL: string;
export declare const SOURCE_EXTRA: string;
export declare function error(message: string, source: any, takeNodeFromSource?: boolean): Status;
export declare abstract class TypeInformation implements tsInterfaces.ITypeFacet {
    private _inheritable;
    constructor(_inheritable: boolean);
    _owner: AbstractType;
    _node: ParseNode;
    node(): ParseNode;
    setNode(node: ParseNode): void;
    owner(): AbstractType;
    isInheritable(): boolean;
    validateSelf(registry: TypeRegistry): Status;
    abstract facetName(): string;
    abstract value(): any;
    abstract requiredType(): AbstractType;
    abstract kind(): tsInterfaces.MetaInformationKind;
}
export declare abstract class Constraint extends TypeInformation {
    constructor();
    abstract check(i: any, parentPath: tsInterfaces.IValidationPath): Status;
    private static intersections;
    protected intersect(t0: AbstractType, t1: AbstractType): AbstractType;
    protected release(t: AbstractType): void;
    nothing(c: Constraint, message?: string): NothingRestrictionWithLocation;
    /**
     * inner implementation of  compute composed restriction from this and parameter restriction
     * @param restriction
     * @return  composed restriction or null;
     */
    composeWith(r: Constraint): Constraint;
    /**
     * returns optimized restiction or this
     * @returns {Constraint}
     */
    preoptimize(): Constraint;
    protected innerOptimize(): Constraint;
    /**
     * performs attempt to compute composed restriction from this and parameter restriction
     * @param restriction
     * @return  composed restriction or null;
     */
    tryCompose(r: Constraint): Constraint;
    kind(): tsInterfaces.MetaInformationKind;
    conflictMessage(otherPath: string, otherValue: any): string;
}
import restr = require("./restrictions");
import { MatchesProperty } from "./restrictions";
export declare var autoCloseFlag: boolean;
/**
 * Registry of the types
 */
export declare class TypeRegistry implements tsInterfaces.ITypeRegistry {
    private _parent;
    private _types;
    private typeList;
    put(alias: string, t: AbstractType): void;
    addType(t: AbstractType): void;
    get(name: string): AbstractType;
    constructor(_parent?: TypeRegistry);
    types(): AbstractType[];
}
export declare class RestrictionsConflict extends Status {
    protected _conflicting: Constraint;
    protected _stack: RestrictionStackEntry;
    constructor(_conflicting: Constraint, _stack: RestrictionStackEntry, source: any);
    getConflictDescription(): string;
    getConflicting(): Constraint;
    getStack(): RestrictionStackEntry;
    toRestriction(): NothingRestrictionWithLocation;
}
export declare var VALIDATED_TYPE: AbstractType;
export declare abstract class AbstractType implements tsInterfaces.IParsedType, tsInterfaces.IHasExtra {
    protected _name: string;
    protected computeConfluent: boolean;
    protected metaInfo: TypeInformation[];
    _subTypes: AbstractType[];
    protected innerid: number;
    protected extras: {
        [name: string]: any;
    };
    getExtra(name: string): any;
    putExtra(name: string, v: any): void;
    id(): number;
    knownProperties(): MatchesProperty[];
    abstract kind(): string;
    protected _locked: boolean;
    lock(): void;
    isLocked(): boolean;
    constructor(_name: string);
    allFacets(): TypeInformation[];
    declaredFacets(): TypeInformation[];
    isSubTypeOf(t: AbstractType): boolean;
    isSuperTypeOf(t: AbstractType): boolean;
    addMeta(info: TypeInformation): void;
    name(): string;
    label(): string;
    /**
     * @return directly known sub types of a given type
     */
    subTypes(): AbstractType[];
    /**
     * @return directly known super types of a given type
     */
    superTypes(): AbstractType[];
    validateType(tr?: TypeRegistry): Status;
    validateHierarchy(rs: Status): void;
    private familyWithArray();
    validateMeta(tr: TypeRegistry): Status;
    private validateFacets(rs);
    allSuperTypes(): AbstractType[];
    private fillSuperTypes(r);
    allSubTypes(): AbstractType[];
    private fillSubTypes(r);
    inherit(name: string): InheritedType;
    /**
     *
     * @return true if type is an inplace type and has no name
     */
    isAnonymous(): boolean;
    /**
     *
     * @return true if type has no associated meta information of restrictions
     */
    isEmpty(): boolean;
    /**
     *
     * @return true if type is an array or extends from an array
     */
    isArray(): boolean;
    propertySet(): string[];
    checkConfluent(): Status;
    /**
     *
     * @return true if type is object or inherited from object
     */
    isObject(): boolean;
    /**
     *
     * @return true if type is object or inherited from object
     */
    isExternal(): boolean;
    /**
     *
     * @return true if type is an boolean type or extends from boolean
     */
    isBoolean(): boolean;
    /**
     *
     * @return true if type is string or inherited from string
     */
    isString(): boolean;
    /**
     *
     * @return true if type is number or inherited from number
     */
    isNumber(): boolean;
    /**
     *
     * @return true if type is number or inherited from number
     */
    isFile(): boolean;
    /**
     *
     * @return true if type is scalar or inherited from scalar
     */
    isScalar(): boolean;
    /**
     * returns true if this type inherits from one of date related types
     */
    isDateTime(): boolean;
    /**
     * returns true if this type inherits from one of date related types
     */
    isDateOnly(): boolean;
    /**
     * returns true if this type inherits from one of date related types
     */
    isTimeOnly(): boolean;
    /**
     * returns true if this type inherits from one of date related types
     */
    isInteger(): boolean;
    /**
     * returns true if this type inherits from one of date related types
     */
    isDateTimeOnly(): boolean;
    /**
     *
     * @return true if type is scalar or inherited from scalar
     */
    isUnknown(): boolean;
    /**
     *
     * @return true if type is scalar or inherited from scalar
     */
    isRecurrent(): boolean;
    /**
     *
     * @return true if type is an built-in type
     */
    isBuiltin(): boolean;
    exampleObject(): any;
    /**
     *
     * @return true if type is an polymorphic type
     */
    isPolymorphic(): boolean;
    /**
     * @return all restrictions associated with type
     */
    restrictions(forValidation?: boolean): Constraint[];
    customFacets(): TypeInformation[];
    allCustomFacets(): TypeInformation[];
    isUnion(): boolean;
    nullable: boolean;
    /**
     * return all type information associated with type
     */
    meta(): TypeInformation[];
    /**
     * validates object against this type without performing AC
     */
    validateDirect(i: any, autoClose?: boolean, nullAllowed?: boolean, path?: tsInterfaces.IValidationPath): Status;
    validate(i: any, autoClose?: boolean, nullAllowed?: boolean): Status;
    /**
     * declares a pattern property on this type,
     * note if type is not inherited from an object type this will move
     * type to inconsistent state
     * @param name - regexp
     * @param type - type of the property
     * @return
     */
    declareMapProperty(name: string, type: AbstractType): AbstractType;
    /**
     * make this type closed type (no unknown properties any more)
     */
    closeUnknownProperties(): void;
    canDoAc(): Status;
    private emptyIntersectionOrDiscriminator(t0, t1);
    checkDiscriminator(t1: AbstractType, t2: AbstractType): Status;
    /**
     * performs automatic classification of the instance
     * @param obj
     * @returns {AbstractType}
     */
    ac(obj: any): AbstractType;
    /**
     * adds new property declaration to this type, note if type is not inherited from an object type this will move
     * type to inconsistent state
     * @param name - name of the property
     * @param type - type of the property
     * @param optional true if property is optinal
     * @return the type with property (this)
     */
    declareProperty(name: string, t: AbstractType, optional: boolean): AbstractType;
    private discriminate(obj, opt);
    /**
     * return instance of type information of particular class
     * @param clazz
     * @returns {any}
     */
    oneMeta<T>(clazz: {
        new (v: any): T;
    }): T;
    /**
     * return all instances of meta information of particular class
     * @param clazz
     * @returns {any}
     */
    metaOfType<T>(clazz: {
        new (v: any): T;
    }): T[];
    declaredMeta(): TypeInformation[];
    descValue(): any;
    isAbstractOrInternal(): boolean;
    typeFamily(): AbstractType[];
}
export declare abstract class Modifier extends TypeInformation {
    requiredType(): RootType;
    kind(): tsInterfaces.MetaInformationKind;
}
export declare class Polymorphic extends Modifier {
    constructor();
    facetName(): string;
    value(): boolean;
}
export declare class Abstract extends Modifier {
    constructor();
    value(): boolean;
    facetName(): string;
}
export declare class Internal extends Modifier {
    constructor();
    facetName(): string;
    value(): boolean;
}
export declare class RootType extends AbstractType {
    kind(): string;
}
export declare class InheritedType extends AbstractType {
    protected _superTypes: AbstractType[];
    protected _contextMeta: restr.MatchesProperty;
    superTypes(): AbstractType[];
    knownProperties(): MatchesProperty[];
    kind(): string;
    meta(): TypeInformation[];
    addSuper(t: AbstractType): void;
    label(): string;
    contextMeta(): restr.MatchesProperty;
    setContextMeta(contextMeta: restr.MatchesProperty): void;
}
export declare abstract class DerivedType extends AbstractType {
    private _options;
    constructor(name: string, _options: AbstractType[]);
    /**
     *
     * @returns all possible options
     */
    allOptions(): AbstractType[];
    options(): AbstractType[];
}
export declare class UnionType extends DerivedType {
    kind(): string;
    constructor(name: string, _options: AbstractType[]);
    isSubTypeOf(t: AbstractType): boolean;
    validate(i: any): Status;
    typeFamily(): AbstractType[];
    knownProperties(): MatchesProperty[];
    validateDirect(i: any, autoClose?: boolean): Status;
    isUnion(): boolean;
    restrictions(): OrRestriction[];
    label(): string;
}
export declare class IntersectionType extends DerivedType {
    kind(): string;
    restrictions(): AndRestriction[];
    label(): string;
}
export declare function builtInRegistry(): TypeRegistry;
export declare function union(name: string, t: AbstractType[]): UnionType;
export declare function intersect(name: string, t: AbstractType[]): IntersectionType;
/**
 * allows you to extend a type from other types
 * @param name
 * @param t
 * @returns {InheritedType}
 */
export declare function derive(name: string, t: AbstractType[]): InheritedType;
/**
 * this function allows you to quickly derive a new type from object;
 * @param name
 * @returns {InheritedType}
 */
export declare function deriveObjectType(name: string): InheritedType;
export declare class NothingRestriction extends Constraint {
    check(i: any): Status;
    requiredType(): RootType;
    facetName(): string;
    value(): string;
}
export declare class RestrictionStackEntry {
    private _previous;
    private _restriction;
    private id;
    constructor(_previous: RestrictionStackEntry, _restriction: Constraint, id: string);
    getRestriction(): Constraint;
    pop(): RestrictionStackEntry;
    push(r: Constraint): RestrictionStackEntry;
}
export declare class NothingRestrictionWithLocation extends NothingRestriction {
    private _entry;
    private _message;
    private _another;
    constructor(_entry: RestrictionStackEntry, _message: string, _another: Constraint);
    getMessage(): string;
    getStack(): RestrictionStackEntry;
    another(): Constraint;
}
export declare abstract class GenericTypeOf extends Constraint {
}
export declare class TypeOfRestriction extends GenericTypeOf {
    private val;
    constructor(val: string);
    check(i: any): Status;
    value(): string;
    requiredType(): RootType;
    facetName(): string;
    composeWith(r: Constraint): Constraint;
    toString(): string;
}
export declare class IntegerRestriction extends GenericTypeOf {
    constructor();
    check(i: any): Status;
    requiredType(): RootType;
    value(): boolean;
    facetName(): string;
}
export declare class NullRestriction extends GenericTypeOf {
    constructor();
    check(i: any): Status;
    requiredType(): RootType;
    value(): boolean;
    facetName(): string;
}
export declare class ScalarRestriction extends GenericTypeOf {
    constructor();
    check(i: any): Status;
    requiredType(): RootType;
    facetName(): string;
    value(): boolean;
}
export declare class OrRestriction extends Constraint {
    private val;
    private _extraMessage;
    private _extraOptionMessage;
    constructor(val: Constraint[], _extraMessage?: string, _extraOptionMessage?: string);
    check(i: any, p: tsInterfaces.IValidationPath): Status;
    value(): any[];
    requiredType(): RootType;
    facetName(): string;
}
export declare class AndRestriction extends Constraint {
    private val;
    constructor(val: Constraint[]);
    value(): any[];
    options(): Constraint[];
    check(i: any, p: tsInterfaces.IValidationPath): Status;
    requiredType(): RootType;
    facetName(): string;
}
/***
 *
 * lets declare built in types
 */
export declare const ANY: RootType;
export declare const SCALAR: InheritedType;
export declare const OBJECT: InheritedType;
export declare const ARRAY: InheritedType;
export declare const NIL: InheritedType;
export declare const EXTERNAL: InheritedType;
export declare const NUMBER: InheritedType;
export declare const INTEGER: InheritedType;
export declare const BOOLEAN: InheritedType;
export declare const STRING: InheritedType;
export declare const DATE_ONLY: InheritedType;
export declare const TIME_ONLY: InheritedType;
export declare const DATETIME_ONLY: InheritedType;
export declare const DATETIME: InheritedType;
export declare const FILE: InheritedType;
export declare const NOTHING: RootType;
export declare const UNION: InheritedType;
export declare const UNKNOWN: InheritedType;
export declare const RECURRENT: InheritedType;
export declare class ExternalType extends InheritedType {
    private _content;
    private json;
    private provider;
    constructor(name: string, _content: string, json: boolean, provider: su.IContentProvider);
    getContentProvider(): su.IContentProvider;
    setContentProvider(provider: su.IContentProvider): void;
    kind(): string;
    isJSON(): boolean;
    schema(): string;
}
export declare function typePath(t: AbstractType): string[];
