"use strict";
/// <reference path="../typings/main.d.ts" />
var validator = require('xmllint-hack2');
var XMLValidator = (function () {
    function XMLValidator(schema) {
        this.schema = schema;
    }
    XMLValidator.prototype.validate = function (xml) {
        var result = validator.validateXML({ xml: xml, schema: this.schema });
        return (result && result.errors && result.errors.map(function (error) { return new Error(error); })) || [];
    };
    return XMLValidator;
}());
exports.XMLValidator = XMLValidator;
function objectToXml(object) {
    if (!object) {
        return '';
    }
    var nodeName = Object.keys(object)[0];
    var root = object[nodeName];
    if (!root && root !== '') {
        return '';
    }
    var result = '<' + nodeName;
    var attributes = root['$'] || {};
    Object.keys(attributes).forEach(function (key) {
        result = result + ' ' + key + '="' + attributes[key] + '"';
    });
    result = result + '>';
    if (typeof root === 'string') {
        result = result + root;
    }
    else {
        Object.keys(root).forEach(function (key) {
            if (key === '$') {
                return;
            }
            if (typeof root[key] === 'object' && !root[key].length) {
                var child = {};
                child[key] = root[key];
                result = result + objectToXml(child);
            }
            else if (typeof root[key] === 'string' || !root[key]) {
                var child = {};
                child[key] = root[key] || '';
                result = result + objectToXml(child);
            }
            else if (typeof root[key] === 'array' || root[key].length) {
                var children = root[key];
                for (var i = 0; i < children.length; i++) {
                    var member = children[i];
                    var child = {};
                    child[key] = member;
                    result = result + objectToXml(child);
                }
            }
        });
    }
    result = result + '</' + nodeName + '>';
    return result;
}
function jsonToXml(jsonObject) {
    var nodeName = jsonObject && Object.keys(jsonObject)[0];
    if (nodeName) {
        var root = jsonObject[nodeName];
        checkAttributes(root);
    }
    return objectToXml(jsonObject);
}
exports.jsonToXml = jsonToXml;
function checkAttributes(root) {
    if (!root || typeof root === 'string') {
        return;
    }
    var attributes = [];
    Object.keys(root).forEach(function (key) {
        if (key.indexOf('@') === 0) {
            var attribute = { key: key, value: root[key] };
            attributes.push(attribute);
        }
        else {
            if (isArray(root[key])) {
                var elements = root[key];
                elements.forEach(function (element) { return checkAttributes(element); });
            }
            else if (typeof root[key] !== 'string') {
                checkAttributes(root[key]);
            }
        }
    });
    if (!root['$']) {
        root['$'] = {};
    }
    var newAttributes = root['$'];
    attributes.forEach(function (attribute) {
        delete root[attribute.key];
        var newKey = attribute.key.substring(1);
        newAttributes[newKey] = attribute.value;
    });
}
function isArray(instance) {
    if (!instance) {
        return false;
    }
    return typeof instance === 'object' && typeof instance.length === 'number';
}
//# sourceMappingURL=xmlUtil.js.map