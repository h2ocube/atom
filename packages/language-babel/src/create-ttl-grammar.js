let  crypto  = require('crypto');
let fs = require('fs-plus');
let path = require('path');
let CompositeDisposable = require('atom').CompositeDisposable;

// This Class is repsonsible for creating a new Tagged Template grammar
// on detection of a changed Tagged Template Configuration in the package settings
module.exports =
class CreateTtlGrammar {

  disposable = new CompositeDisposable();
  configChangedTimer= null;
  TTLSCOPENAME = `languagebabel.ttlextension`

  constructor(observeConfig = false) {
    if (observeConfig)   {
      // look for changes in tagged template handlers
      this.disposable.add(atom.config.observe('language-babel.taggedTemplateGrammar', this.observeTtlConfig.bind(this)));
    }
  }

  destroy() {
    this.disposable.dispose();
  }

  // add new grammars to registry
  addGrammars(filename) {
    return new Promise((resolve, reject) => {
      atom.grammars.loadGrammar(filename, (error, grammar) => {
        if ( error) reject({err: err, module: 'addGrammars' })
        else resolve()
      });
    });

  }

  // Check if the grammar exists under this SHA256 file name
  // If not then remove all ttl grammars and create a new one
  // This returns a Promise that resolves  with a filename
  // if a new grammar was created or rejects if a problem.
  createGrammar({ttlFilename, ttlFilenameAbsolute, grammarText}) {
    return new Promise( (resolve, reject) => {

      this.noGrammarFileExists(ttlFilename)
        .then( () => this.removeGrammars() )
        .then( () => { this.removeTtlLanguageFiles() } )
        .then( () => this.createGrammarFile(ttlFilenameAbsolute, grammarText) )
        .then( () => this.addGrammars(ttlFilenameAbsolute) )
        .then( () => resolve(ttlFilename) )
        .catch( (err) => {
          reject(err);
        });
    });
  }

  // write the ttl grammar file for this config
  createGrammarFile(filename,text) {
    return new Promise((resolve, reject) => {
      fs.writeFile(filename, text, (err) => {
        if (err) reject({err: err, module: 'createGrammarFile' });
        else resolve('New Grammar Created');
      })
    });
  }

  // create a Grammar file's JSON text
  createGrammarText() {
    return `{
  "comment": "Auto generated Tag Extensions for language-babel",
  "comment": "Please do not edit this file directly",
  "scopeName": "${this.TTLSCOPENAME}",
  "fileTypes": [],
  "patterns": [
    ${this.getTtlConfig().map( (ttlString) => (this.createGrammarPatterns(ttlString))  ) }
  ]
}`
  }

  // Create a grammar's pattern derived from a the tagged template string
  // in the form matchString:includeScope
  createGrammarPatterns(ttlString) {
    let lastColonIndex = ttlString.lastIndexOf(':');
    let matchString = ttlString.substring(0, lastColonIndex);
    let includeScope = ttlString.substring(lastColonIndex+1);
    const isValidIncludeScope = /^([a-zA-Z]\w*\.?)*(\w#([a-zA-Z]\w*\.?)*)?\w$/;

    if ( matchString.length < 1 || !isValidIncludeScope.test(includeScope)) {
      throw(`Error in the Tagged Template Grammar String ${ttlString}`);
      return ``;
    }

    const escapeStringRegExp = /[|\\{}()[\]^$+*?.]/g;
    // Get a valid regexp escaped string. e.g. '/** @html */' -> '\/\*\* @html \*\/'
    matchString = matchString.replace(escapeStringRegExp, '\\\\$&');

    return `{
      "begin": "\\\\s*+(${matchString})\\\\s*(\`)",
      "beginCaptures": {
        "1": { "name": "entity.name.tag.grapahql.js" },
        "4": { "name": "punctuation.definition.quasi.begin.js" }
      },
      "end": "\\\\s*(?<!\\\\\\\\)(\`)",
      "endCaptures": {
        "1": { "name": "punctuation.definition.quasi.end.js" }
      },
      "patterns": [
        { "include": "${includeScope}" }
      ]
    }`
  }

  // get full path to the language-babel grammar file dir
  getGrammarPath() {
    return path.normalize(
      path.resolve(atom.packages.loadedPackages['language-babel'].path, './grammars')
    );
  }

  // get an array of all language-babel grammar files
  getGrammarFiles() {
    return new Promise((resolve,reject) => {
      fs.readdir(this.getGrammarPath(),(err, data) => {
        if (err) reject({err: err, module: 'getGrammarFiles' });
        else {
          resolve(data);
        }
      });
    });
  }

  // read configurations for tagged templates
  getTtlConfig() {
    return atom.config.get('language-babel').taggedTemplateGrammar;
  }

  // get an array of grammar tagged template extension filenames
  getTtlGrammarFiles() {
    var regex = /ttl-/;
    return this.getGrammarFiles().then(dirFiles => dirFiles.filter(function(filename) {
      return regex.test(filename);
    }));
  }

  // generate a SHA256 for some text
  generateTtlSHA256(stringToHash) {
    var hash = crypto.createHash('sha256');
    hash.update(stringToHash);
    return hash.digest('hex');
  }

  // tagged template filename
  makeTtlGrammarFilename(hashString) {
    return `ttl-${hashString}.json`
  }

  // get a fully qualified filename
  makeTtlGrammarFilenameAbsoulute(ttlFilename) {
    return path.resolve(this.getGrammarPath(), ttlFilename);
  }

  // checks a ttl grammar filename exist and is writable
  // returns a Promise that rejects if file exists
  noGrammarFileExists(ttlFilename) {
    return new Promise((resolve, reject) => {
      fs.access(this.makeTtlGrammarFilenameAbsoulute(ttlFilename), fs.F_OK, (err) => {
        !!!err ? reject({err: false, module: 'noGrammarFileExists' }): resolve(!!!err);
      });
    });
  }

  // observe changes in the taggedTemplateGrammar config which take place
  // because observed config changes are fired as a user types them inside
  // settings we need to delay processing the array strings, until last char
  // entered was setTimeout seconds ago. parse tagged template configuration
  // and then create grammar and generate a SHA256 hash from the grammar
  observeTtlConfig(value) {
    if (!!this.configChangedTimer) clearTimeout(this.configChangedTimer);
    this.configChangedTimer = setTimeout( () => {
      try {
        const grammarText = this.createGrammarText();
        const hash = this.generateTtlSHA256(grammarText);
        const ttlFilename = this.makeTtlGrammarFilename(hash);
        const ttlFilenameAbsolute = this.makeTtlGrammarFilenameAbsoulute(ttlFilename);
        let p = this.createGrammar({ttlFilename, ttlFilenameAbsolute, grammarText })
          .then( () => atom.notifications.addInfo('language-babel', {description: `Grammar created at \n${ttlFilenameAbsolute}`,dismissable: true}))
          .catch( (err) => {
              if (err.err) {
                atom.notifications.addWarning('language-babel', {description: `Module: ${err.module} got an Error:${err.err}`,dismissable: true});
              }
          });
      }
      catch(err) {
        atom.notifications.addError(err, {dismissable: true});
        return;
      }
    }, 10000);
  }

  // Remove grammars before upodating
  removeGrammars() {
    atom.grammars.removeGrammarForScopeName(this.TTLSCOPENAME);
  }

  // remove all language files in tagged template GrammarFiles array
  removeTtlLanguageFiles() {
    return this.getTtlGrammarFiles().then( (ttlGrammarFiles) => {
      for (let ttlGrammarFilename of ttlGrammarFiles) {
        let ttlGrammarFileAbsoulte = this.makeTtlGrammarFilenameAbsoulute(ttlGrammarFilename);
        fs.unlink(ttlGrammarFileAbsoulte);
      }
    });

  }
};
