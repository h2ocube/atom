'use strict';

let crypto = require('crypto');
let fs = require('fs-plus');
let path = require('path');
let CompositeDisposable = require('atom').CompositeDisposable;

// This Class is repsonsible for creating a new Tagged Template grammar
// on detection of a changed Tagged Template Configuration in the package settings
module.exports = class CreateTtlGrammar {

  constructor() {
    let observeConfig = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
    this.disposable = new CompositeDisposable();
    this.configChangedTimer = null;
    this.TTLSCOPENAME = `languagebabel.ttlextension`;

    if (observeConfig) {
      // look for changes in tagged template handlers
      this.disposable.add(atom.config.observe('language-babel.taggedTemplateGrammar', this.observeTtlConfig.bind(this)));
    }
  }

  destroy() {
    this.disposable.dispose();
  }

  // add new grammars to registry
  addGrammars(filename) {
    return new Promise((resolve, reject) => {
      atom.grammars.loadGrammar(filename, (error, grammar) => {
        if (error) reject({ err: err, module: 'addGrammars' });else resolve();
      });
    });
  }

  // Check if the grammar exists under this SHA256 file name
  // If not then remove all ttl grammars and create a new one
  // This returns a Promise that resolves  with a filename
  // if a new grammar was created or rejects if a problem.
  createGrammar(_ref) {
    let ttlFilename = _ref.ttlFilename;
    let ttlFilenameAbsolute = _ref.ttlFilenameAbsolute;
    let grammarText = _ref.grammarText;

    return new Promise((resolve, reject) => {

      this.noGrammarFileExists(ttlFilename).then(() => this.removeGrammars()).then(() => {
        this.removeTtlLanguageFiles();
      }).then(() => this.createGrammarFile(ttlFilenameAbsolute, grammarText)).then(() => this.addGrammars(ttlFilenameAbsolute)).then(() => resolve(ttlFilename)).catch(err => {
        reject(err);
      });
    });
  }

  // write the ttl grammar file for this config
  createGrammarFile(filename, text) {
    return new Promise((resolve, reject) => {
      fs.writeFile(filename, text, err => {
        if (err) reject({ err: err, module: 'createGrammarFile' });else resolve('New Grammar Created');
      });
    });
  }

  // create a Grammar file's JSON text
  createGrammarText() {
    return `{
  "comment": "Auto generated Tag Extensions for language-babel",
  "comment": "Please do not edit this file directly",
  "scopeName": "${ this.TTLSCOPENAME }",
  "fileTypes": [],
  "patterns": [
    ${ this.getTtlConfig().map(ttlString => this.createGrammarPatterns(ttlString)) }
  ]
}`;
  }

  // Create a grammar's pattern derived from a the tagged template string
  // in the form matchString:includeScope
  createGrammarPatterns(ttlString) {
    let lastColonIndex = ttlString.lastIndexOf(':');
    let matchString = ttlString.substring(0, lastColonIndex);
    let includeScope = ttlString.substring(lastColonIndex + 1);
    const isValidIncludeScope = /^([a-zA-Z]\w*\.?)*(\w#([a-zA-Z]\w*\.?)*)?\w$/;

    if (matchString.length < 1 || !isValidIncludeScope.test(includeScope)) {
      throw `Error in the Tagged Template Grammar String ${ ttlString }`;
      return ``;
    }

    const escapeStringRegExp = /[|\\{}()[\]^$+*?.]/g;
    // Get a valid regexp escaped string. e.g. '/** @html */' -> '\/\*\* @html \*\/'
    matchString = matchString.replace(escapeStringRegExp, '\\\\$&');

    return `{
      "begin": "\\\\s*+(${ matchString })\\\\s*(\`)",
      "beginCaptures": {
        "1": { "name": "entity.name.tag.grapahql.js" },
        "4": { "name": "punctuation.definition.quasi.begin.js" }
      },
      "end": "\\\\s*(?<!\\\\\\\\)(\`)",
      "endCaptures": {
        "1": { "name": "punctuation.definition.quasi.end.js" }
      },
      "patterns": [
        { "include": "${ includeScope }" }
      ]
    }`;
  }

  // get full path to the language-babel grammar file dir
  getGrammarPath() {
    return path.normalize(path.resolve(atom.packages.loadedPackages['language-babel'].path, './grammars'));
  }

  // get an array of all language-babel grammar files
  getGrammarFiles() {
    return new Promise((resolve, reject) => {
      fs.readdir(this.getGrammarPath(), (err, data) => {
        if (err) reject({ err: err, module: 'getGrammarFiles' });else {
          resolve(data);
        }
      });
    });
  }

  // read configurations for tagged templates
  getTtlConfig() {
    return atom.config.get('language-babel').taggedTemplateGrammar;
  }

  // get an array of grammar tagged template extension filenames
  getTtlGrammarFiles() {
    var regex = /ttl-/;
    return this.getGrammarFiles().then(dirFiles => dirFiles.filter(function (filename) {
      return regex.test(filename);
    }));
  }

  // generate a SHA256 for some text
  generateTtlSHA256(stringToHash) {
    var hash = crypto.createHash('sha256');
    hash.update(stringToHash);
    return hash.digest('hex');
  }

  // tagged template filename
  makeTtlGrammarFilename(hashString) {
    return `ttl-${ hashString }.json`;
  }

  // get a fully qualified filename
  makeTtlGrammarFilenameAbsoulute(ttlFilename) {
    return path.resolve(this.getGrammarPath(), ttlFilename);
  }

  // checks a ttl grammar filename exist and is writable
  // returns a Promise that rejects if file exists
  noGrammarFileExists(ttlFilename) {
    return new Promise((resolve, reject) => {
      fs.access(this.makeTtlGrammarFilenameAbsoulute(ttlFilename), fs.F_OK, err => {
        !!!err ? reject({ err: false, module: 'noGrammarFileExists' }) : resolve(!!!err);
      });
    });
  }

  // observe changes in the taggedTemplateGrammar config which take place
  // because observed config changes are fired as a user types them inside
  // settings we need to delay processing the array strings, until last char
  // entered was setTimeout seconds ago. parse tagged template configuration
  // and then create grammar and generate a SHA256 hash from the grammar
  observeTtlConfig(value) {
    if (!!this.configChangedTimer) clearTimeout(this.configChangedTimer);
    this.configChangedTimer = setTimeout(() => {
      try {
        const grammarText = this.createGrammarText();
        const hash = this.generateTtlSHA256(grammarText);
        const ttlFilename = this.makeTtlGrammarFilename(hash);
        const ttlFilenameAbsolute = this.makeTtlGrammarFilenameAbsoulute(ttlFilename);
        let p = this.createGrammar({ ttlFilename, ttlFilenameAbsolute, grammarText }).then(() => atom.notifications.addInfo('language-babel', { description: `Grammar created at \n${ ttlFilenameAbsolute }`, dismissable: true })).catch(err => {
          if (err.err) {
            atom.notifications.addWarning('language-babel', { description: `Module: ${ err.module } got an Error:${ err.err }`, dismissable: true });
          }
        });
      } catch (err) {
        atom.notifications.addError(err, { dismissable: true });
        return;
      }
    }, 10000);
  }

  // Remove grammars before upodating
  removeGrammars() {
    atom.grammars.removeGrammarForScopeName(this.TTLSCOPENAME);
  }

  // remove all language files in tagged template GrammarFiles array
  removeTtlLanguageFiles() {
    return this.getTtlGrammarFiles().then(ttlGrammarFiles => {
      for (let ttlGrammarFilename of ttlGrammarFiles) {
        let ttlGrammarFileAbsoulte = this.makeTtlGrammarFilenameAbsoulute(ttlGrammarFilename);
        fs.unlink(ttlGrammarFileAbsoulte);
      }
    });
  }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNyZWF0ZS10dGwtZ3JhbW1hci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUssU0FBVSxRQUFRLFFBQVIsQ0FBZjtBQUNBLElBQUksS0FBSyxRQUFRLFNBQVIsQ0FBVDtBQUNBLElBQUksT0FBTyxRQUFRLE1BQVIsQ0FBWDtBQUNBLElBQUksc0JBQXNCLFFBQVEsTUFBUixFQUFnQixtQkFBMUM7Ozs7QUFJQSxPQUFPLE9BQVAsR0FDQSxNQUFNLGdCQUFOLENBQXVCOztBQU1yQixnQkFBbUM7QUFBQSxRQUF2QixhQUF1Qix5REFBUCxLQUFPO0FBQUEsU0FKbkMsVUFJbUMsR0FKdEIsSUFBSSxtQkFBSixFQUlzQjtBQUFBLFNBSG5DLGtCQUdtQyxHQUhmLElBR2U7QUFBQSxTQUZuQyxZQUVtQyxHQUZwQixDQUFDLDBCQUFELENBRW9COztBQUNqQyxRQUFJLGFBQUosRUFBcUI7O0FBRW5CLFdBQUssVUFBTCxDQUFnQixHQUFoQixDQUFvQixLQUFLLE1BQUwsQ0FBWSxPQUFaLENBQW9CLHNDQUFwQixFQUE0RCxLQUFLLGdCQUFMLENBQXNCLElBQXRCLENBQTJCLElBQTNCLENBQTVELENBQXBCO0FBQ0Q7QUFDRjs7QUFFRCxZQUFVO0FBQ1IsU0FBSyxVQUFMLENBQWdCLE9BQWhCO0FBQ0Q7OztBQUdELGNBQVksUUFBWixFQUFzQjtBQUNwQixXQUFPLElBQUksT0FBSixDQUFZLENBQUMsT0FBRCxFQUFVLE1BQVYsS0FBcUI7QUFDdEMsV0FBSyxRQUFMLENBQWMsV0FBZCxDQUEwQixRQUExQixFQUFvQyxDQUFDLEtBQUQsRUFBUSxPQUFSLEtBQW9CO0FBQ3RELFlBQUssS0FBTCxFQUFZLE9BQU8sRUFBQyxLQUFLLEdBQU4sRUFBVyxRQUFRLGFBQW5CLEVBQVAsRUFBWixLQUNLO0FBQ04sT0FIRDtBQUlELEtBTE0sQ0FBUDtBQU9EOzs7Ozs7QUFNRCxzQkFBK0Q7QUFBQSxRQUFoRCxXQUFnRCxRQUFoRCxXQUFnRDtBQUFBLFFBQW5DLG1CQUFt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QUFDMUQsV0FBSyxJQUFJLGtCQUFULElBQStCLGVBQS9CLEVBQWdEO0FBQzlDLFlBQUkseUJBQXlCLEtBQUssK0JBQUwsQ0FBcUMsa0JBQXJDLENBQTdCO0FBQ0EsV0FBRyxNQUFILENBQVUsc0JBQVY7QUFDRDtBQUNGLEtBTE0sQ0FBUDtBQU9EO0FBNU1vQixDQUR2QiIsImZpbGUiOiJjcmVhdGUtdHRsLWdyYW1tYXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgIGNyeXB0byAgPSByZXF1aXJlKCdjcnlwdG8nKTtcclxubGV0IGZzID0gcmVxdWlyZSgnZnMtcGx1cycpO1xyXG5sZXQgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxubGV0IENvbXBvc2l0ZURpc3Bvc2FibGUgPSByZXF1aXJlKCdhdG9tJykuQ29tcG9zaXRlRGlzcG9zYWJsZTtcclxuXHJcbi8vIFRoaXMgQ2xhc3MgaXMgcmVwc29uc2libGUgZm9yIGNyZWF0aW5nIGEgbmV3IFRhZ2dlZCBUZW1wbGF0ZSBncmFtbWFyXHJcbi8vIG9uIGRldGVjdGlvbiBvZiBhIGNoYW5nZWQgVGFnZ2VkIFRlbXBsYXRlIENvbmZpZ3VyYXRpb24gaW4gdGhlIHBhY2thZ2Ugc2V0dGluZ3NcclxubW9kdWxlLmV4cG9ydHMgPVxyXG5jbGFzcyBDcmVhdGVUdGxHcmFtbWFyIHtcclxuXHJcbiAgZGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XHJcbiAgY29uZmlnQ2hhbmdlZFRpbWVyPSBudWxsO1xyXG4gIFRUTFNDT1BFTkFNRSA9IGBsYW5ndWFnZWJhYmVsLnR0bGV4dGVuc2lvbmBcclxuXHJcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZUNvbmZpZyA9IGZhbHNlKSB7XHJcbiAgICBpZiAob2JzZXJ2ZUNvbmZpZykgICB7XHJcbiAgICAgIC8vIGxvb2sgZm9yIGNoYW5nZXMgaW4gdGFnZ2VkIHRlbXBsYXRlIGhhbmRsZXJzXHJcbiAgICAgIHRoaXMuZGlzcG9zYWJsZS5hZGQoYXRvbS5jb25maWcub2JzZXJ2ZSgnbGFuZ3VhZ2UtYmFiZWwudGFnZ2VkVGVtcGxhdGVHcmFtbWFyJywgdGhpcy5vYnNlcnZlVHRsQ29uZmlnLmJpbmQodGhpcykpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmRpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gYWRkIG5ldyBncmFtbWFycyB0byByZWdpc3RyeVxyXG4gIGFkZEdyYW1tYXJzKGZpbGVuYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBhdG9tLmdyYW1tYXJzLmxvYWRHcmFtbWFyKGZpbGVuYW1lLCAoZXJyb3IsIGdyYW1tYXIpID0+IHtcclxuICAgICAgICBpZiAoIGVycm9yKSByZWplY3Qoe2VycjogZXJyLCBtb2R1bGU6ICdhZGRHcmFtbWFycycgfSlcclxuICAgICAgICBlbHNlIHJlc29sdmUoKVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGlmIHRoZSBncmFtbWFyIGV4aXN0cyB1bmRlciB0aGlzIFNIQTI1NiBmaWxlIG5hbWVcclxuICAvLyBJZiBub3QgdGhlbiByZW1vdmUgYWxsIHR0bCBncmFtbWFycyBhbmQgY3JlYXRlIGEgbmV3IG9uZVxyXG4gIC8vIFRoaXMgcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyAgd2l0aCBhIGZpbGVuYW1lXHJcbiAgLy8gaWYgYSBuZXcgZ3JhbW1hciB3YXMgY3JlYXRlZCBvciByZWplY3RzIGlmIGEgcHJvYmxlbS5cclxuICBjcmVhdGVHcmFtbWFyKHt0dGxGaWxlbmFtZSwgdHRsRmlsZW5hbWVBYnNvbHV0ZSwgZ3JhbW1hclRleHR9KSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuXHJcbiAgICAgIHRoaXMubm9HcmFtbWFyRmlsZUV4aXN0cyh0dGxGaWxlbmFtZSlcclxuICAgICAgICAudGhlbiggKCkgPT4gdGhpcy5yZW1vdmVHcmFtbWFycygpIClcclxuICAgICAgICAudGhlbiggKCkgPT4geyB0aGlzLnJlbW92ZVR0bExhbmd1YWdlRmlsZXMoKSB9IClcclxuICAgICAgICAudGhlbiggKCkgPT4gdGhpcy5jcmVhdGVHcmFtbWFyRmlsZSh0dGxGaWxlbmFtZUFic29sdXRlLCBncmFtbWFyVGV4dCkgKVxyXG4gICAgICAgIC50aGVuKCAoKSA9PiB0aGlzLmFkZEdyYW1tYXJzKHR0bEZpbGVuYW1lQWJzb2x1dGUpIClcclxuICAgICAgICAudGhlbiggKCkgPT4gcmVzb2x2ZSh0dGxGaWxlbmFtZSkgKVxyXG4gICAgICAgIC5jYXRjaCggKGVycikgPT4ge1xyXG4gICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIHdyaXRlIHRoZSB0dGwgZ3JhbW1hciBmaWxlIGZvciB0aGlzIGNvbmZpZ1xyXG4gIGNyZWF0ZUdyYW1tYXJGaWxlKGZpbGVuYW1lLHRleHQpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGZzLndyaXRlRmlsZShmaWxlbmFtZSwgdGV4dCwgKGVycikgPT4ge1xyXG4gICAgICAgIGlmIChlcnIpIHJlamVjdCh7ZXJyOiBlcnIsIG1vZHVsZTogJ2NyZWF0ZUdyYW1tYXJGaWxlJyB9KTtcclxuICAgICAgICBlbHNlIHJlc29sdmUoJ05ldyBHcmFtbWFyIENyZWF0ZWQnKTtcclxuICAgICAgfSlcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gY3JlYXRlIGEgR3JhbW1hciBmaWxlJ3MgSlNPTiB0ZXh0XHJcbiAgY3JlYXRlR3JhbW1hclRleHQoKSB7XHJcbiAgICByZXR1cm4gYHtcclxuICBcImNvbW1lbnRcIjogXCJBdXRvIGdlbmVyYXRlZCBUYWcgRXh0ZW5zaW9ucyBmb3IgbGFuZ3VhZ2UtYmFiZWxcIixcclxuICBcImNvbW1lbnRcIjogXCJQbGVhc2UgZG8gbm90IGVkaXQgdGhpcyBmaWxlIGRpcmVjdGx5XCIsXHJcbiAgXCJzY29wZU5hbWVcIjogXCIke3RoaXMuVFRMU0NPUEVOQU1FfVwiLFxyXG4gIFwiZmlsZVR5cGVzXCI6IFtdLFxyXG4gIFwicGF0dGVybnNcIjogW1xyXG4gICAgJHt0aGlzLmdldFR0bENvbmZpZygpLm1hcCggKHR0bFN0cmluZykgPT4gKHRoaXMuY3JlYXRlR3JhbW1hclBhdHRlcm5zKHR0bFN0cmluZykpICApIH1cclxuICBdXHJcbn1gXHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgYSBncmFtbWFyJ3MgcGF0dGVybiBkZXJpdmVkIGZyb20gYSB0aGUgdGFnZ2VkIHRlbXBsYXRlIHN0cmluZ1xyXG4gIC8vIGluIHRoZSBmb3JtIG1hdGNoU3RyaW5nOmluY2x1ZGVTY29wZVxyXG4gIGNyZWF0ZUdyYW1tYXJQYXR0ZXJucyh0dGxTdHJpbmcpIHtcclxuICAgIGxldCBsYXN0Q29sb25JbmRleCA9IHR0bFN0cmluZy5sYXN0SW5kZXhPZignOicpO1xyXG4gICAgbGV0IG1hdGNoU3RyaW5nID0gdHRsU3RyaW5nLnN1YnN0cmluZygwLCBsYXN0Q29sb25JbmRleCk7XHJcbiAgICBsZXQgaW5jbHVkZVNjb3BlID0gdHRsU3RyaW5nLnN1YnN0cmluZyhsYXN0Q29sb25JbmRleCsxKTtcclxuICAgIGNvbnN0IGlzVmFsaWRJbmNsdWRlU2NvcGUgPSAvXihbYS16QS1aXVxcdypcXC4/KSooXFx3IyhbYS16QS1aXVxcdypcXC4/KSopP1xcdyQvO1xyXG5cclxuICAgIGlmICggbWF0Y2hTdHJpbmcubGVuZ3RoIDwgMSB8fCAhaXNWYWxpZEluY2x1ZGVTY29wZS50ZXN0KGluY2x1ZGVTY29wZSkpIHtcclxuICAgICAgdGhyb3coYEVycm9yIGluIHRoZSBUYWdnZWQgVGVtcGxhdGUgR3JhbW1hciBTdHJpbmcgJHt0dGxTdHJpbmd9YCk7XHJcbiAgICAgIHJldHVybiBgYDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBlc2NhcGVTdHJpbmdSZWdFeHAgPSAvW3xcXFxce30oKVtcXF1eJCsqPy5dL2c7XHJcbiAgICAvLyBHZXQgYSB2YWxpZCByZWdleHAgZXNjYXBlZCBzdHJpbmcuIGUuZy4gJy8qKiBAaHRtbCAqLycgLT4gJ1xcL1xcKlxcKiBAaHRtbCBcXCpcXC8nXHJcbiAgICBtYXRjaFN0cmluZyA9IG1hdGNoU3RyaW5nLnJlcGxhY2UoZXNjYXBlU3RyaW5nUmVnRXhwLCAnXFxcXFxcXFwkJicpO1xyXG5cclxuICAgIHJldHVybiBge1xyXG4gICAgICBcImJlZ2luXCI6IFwiXFxcXFxcXFxzKisoJHttYXRjaFN0cmluZ30pXFxcXFxcXFxzKihcXGApXCIsXHJcbiAgICAgIFwiYmVnaW5DYXB0dXJlc1wiOiB7XHJcbiAgICAgICAgXCIxXCI6IHsgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUudGFnLmdyYXBhaHFsLmpzXCIgfSxcclxuICAgICAgICBcIjRcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnF1YXNpLmJlZ2luLmpzXCIgfVxyXG4gICAgICB9LFxyXG4gICAgICBcImVuZFwiOiBcIlxcXFxcXFxccyooPzwhXFxcXFxcXFxcXFxcXFxcXCkoXFxgKVwiLFxyXG4gICAgICBcImVuZENhcHR1cmVzXCI6IHtcclxuICAgICAgICBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnF1YXNpLmVuZC5qc1wiIH1cclxuICAgICAgfSxcclxuICAgICAgXCJwYXR0ZXJuc1wiOiBbXHJcbiAgICAgICAgeyBcImluY2x1ZGVcIjogXCIke2luY2x1ZGVTY29wZX1cIiB9XHJcbiAgICAgIF1cclxuICAgIH1gXHJcbiAgfVxyXG5cclxuICAvLyBnZXQgZnVsbCBwYXRoIHRvIHRoZSBsYW5ndWFnZS1iYWJlbCBncmFtbWFyIGZpbGUgZGlyXHJcbiAgZ2V0R3JhbW1hclBhdGgoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5ub3JtYWxpemUoXHJcbiAgICAgIHBhdGgucmVzb2x2ZShhdG9tLnBhY2thZ2VzLmxvYWRlZFBhY2thZ2VzWydsYW5ndWFnZS1iYWJlbCddLnBhdGgsICcuL2dyYW1tYXJzJylcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBnZXQgYW4gYXJyYXkgb2YgYWxsIGxhbmd1YWdlLWJhYmVsIGdyYW1tYXIgZmlsZXNcclxuICBnZXRHcmFtbWFyRmlsZXMoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KSA9PiB7XHJcbiAgICAgIGZzLnJlYWRkaXIodGhpcy5nZXRHcmFtbWFyUGF0aCgpLChlcnIsIGRhdGEpID0+IHtcclxuICAgICAgICBpZiAoZXJyKSByZWplY3Qoe2VycjogZXJyLCBtb2R1bGU6ICdnZXRHcmFtbWFyRmlsZXMnIH0pO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyByZWFkIGNvbmZpZ3VyYXRpb25zIGZvciB0YWdnZWQgdGVtcGxhdGVzXHJcbiAgZ2V0VHRsQ29uZmlnKCkge1xyXG4gICAgcmV0dXJuIGF0b20uY29uZmlnLmdldCgnbGFuZ3VhZ2UtYmFiZWwnKS50YWdnZWRUZW1wbGF0ZUdyYW1tYXI7XHJcbiAgfVxyXG5cclxuICAvLyBnZXQgYW4gYXJyYXkgb2YgZ3JhbW1hciB0YWdnZWQgdGVtcGxhdGUgZXh0ZW5zaW9uIGZpbGVuYW1lc1xyXG4gIGdldFR0bEdyYW1tYXJGaWxlcygpIHtcclxuICAgIHZhciByZWdleCA9IC90dGwtLztcclxuICAgIHJldHVybiB0aGlzLmdldEdyYW1tYXJGaWxlcygpLnRoZW4oZGlyRmlsZXMgPT4gZGlyRmlsZXMuZmlsdGVyKGZ1bmN0aW9uKGZpbGVuYW1lKSB7XHJcbiAgICAgIHJldHVybiByZWdleC50ZXN0KGZpbGVuYW1lKTtcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIC8vIGdlbmVyYXRlIGEgU0hBMjU2IGZvciBzb21lIHRleHRcclxuICBnZW5lcmF0ZVR0bFNIQTI1NihzdHJpbmdUb0hhc2gpIHtcclxuICAgIHZhciBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpO1xyXG4gICAgaGFzaC51cGRhdGUoc3RyaW5nVG9IYXNoKTtcclxuICAgIHJldHVybiBoYXNoLmRpZ2VzdCgnaGV4Jyk7XHJcbiAgfVxyXG5cclxuICAvLyB0YWdnZWQgdGVtcGxhdGUgZmlsZW5hbWVcclxuICBtYWtlVHRsR3JhbW1hckZpbGVuYW1lKGhhc2hTdHJpbmcpIHtcclxuICAgIHJldHVybiBgdHRsLSR7aGFzaFN0cmluZ30uanNvbmBcclxuICB9XHJcblxyXG4gIC8vIGdldCBhIGZ1bGx5IHF1YWxpZmllZCBmaWxlbmFtZVxyXG4gIG1ha2VUdGxHcmFtbWFyRmlsZW5hbWVBYnNvdWx1dGUodHRsRmlsZW5hbWUpIHtcclxuICAgIHJldHVybiBwYXRoLnJlc29sdmUodGhpcy5nZXRHcmFtbWFyUGF0aCgpLCB0dGxGaWxlbmFtZSk7XHJcbiAgfVxyXG5cclxuICAvLyBjaGVja3MgYSB0dGwgZ3JhbW1hciBmaWxlbmFtZSBleGlzdCBhbmQgaXMgd3JpdGFibGVcclxuICAvLyByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlamVjdHMgaWYgZmlsZSBleGlzdHNcclxuICBub0dyYW1tYXJGaWxlRXhpc3RzKHR0bEZpbGVuYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBmcy5hY2Nlc3ModGhpcy5tYWtlVHRsR3JhbW1hckZpbGVuYW1lQWJzb3VsdXRlKHR0bEZpbGVuYW1lKSwgZnMuRl9PSywgKGVycikgPT4ge1xyXG4gICAgICAgICEhIWVyciA/IHJlamVjdCh7ZXJyOiBmYWxzZSwgbW9kdWxlOiAnbm9HcmFtbWFyRmlsZUV4aXN0cycgfSk6IHJlc29sdmUoISEhZXJyKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIG9ic2VydmUgY2hhbmdlcyBpbiB0aGUgdGFnZ2VkVGVtcGxhdGVHcmFtbWFyIGNvbmZpZyB3aGljaCB0YWtlIHBsYWNlXHJcbiAgLy8gYmVjYXVzZSBvYnNlcnZlZCBjb25maWcgY2hhbmdlcyBhcmUgZmlyZWQgYXMgYSB1c2VyIHR5cGVzIHRoZW0gaW5zaWRlXHJcbiAgLy8gc2V0dGluZ3Mgd2UgbmVlZCB0byBkZWxheSBwcm9jZXNzaW5nIHRoZSBhcnJheSBzdHJpbmdzLCB1bnRpbCBsYXN0IGNoYXJcclxuICAvLyBlbnRlcmVkIHdhcyBzZXRUaW1lb3V0IHNlY29uZHMgYWdvLiBwYXJzZSB0YWdnZWQgdGVtcGxhdGUgY29uZmlndXJhdGlvblxyXG4gIC8vIGFuZCB0aGVuIGNyZWF0ZSBncmFtbWFyIGFuZCBnZW5lcmF0ZSBhIFNIQTI1NiBoYXNoIGZyb20gdGhlIGdyYW1tYXJcclxuICBvYnNlcnZlVHRsQ29uZmlnKHZhbHVlKSB7XHJcbiAgICBpZiAoISF0aGlzLmNvbmZpZ0NoYW5nZWRUaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuY29uZmlnQ2hhbmdlZFRpbWVyKTtcclxuICAgIHRoaXMuY29uZmlnQ2hhbmdlZFRpbWVyID0gc2V0VGltZW91dCggKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGdyYW1tYXJUZXh0ID0gdGhpcy5jcmVhdGVHcmFtbWFyVGV4dCgpO1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmdlbmVyYXRlVHRsU0hBMjU2KGdyYW1tYXJUZXh0KTtcclxuICAgICAgICBjb25zdCB0dGxGaWxlbmFtZSA9IHRoaXMubWFrZVR0bEdyYW1tYXJGaWxlbmFtZShoYXNoKTtcclxuICAgICAgICBjb25zdCB0dGxGaWxlbmFtZUFic29sdXRlID0gdGhpcy5tYWtlVHRsR3JhbW1hckZpbGVuYW1lQWJzb3VsdXRlKHR0bEZpbGVuYW1lKTtcclxuICAgICAgICBsZXQgcCA9IHRoaXMuY3JlYXRlR3JhbW1hcih7dHRsRmlsZW5hbWUsIHR0bEZpbGVuYW1lQWJzb2x1dGUsIGdyYW1tYXJUZXh0IH0pXHJcbiAgICAgICAgICAudGhlbiggKCkgPT4gYXRvbS5ub3RpZmljYXRpb25zLmFkZEluZm8oJ2xhbmd1YWdlLWJhYmVsJywge2Rlc2NyaXB0aW9uOiBgR3JhbW1hciBjcmVhdGVkIGF0IFxcbiR7dHRsRmlsZW5hbWVBYnNvbHV0ZX1gLGRpc21pc3NhYmxlOiB0cnVlfSkpXHJcbiAgICAgICAgICAuY2F0Y2goIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICBpZiAoZXJyLmVycikge1xyXG4gICAgICAgICAgICAgICAgYXRvbS5ub3RpZmljYXRpb25zLmFkZFdhcm5pbmcoJ2xhbmd1YWdlLWJhYmVsJywge2Rlc2NyaXB0aW9uOiBgTW9kdWxlOiAke2Vyci5tb2R1bGV9IGdvdCBhbiBFcnJvcjoke2Vyci5lcnJ9YCxkaXNtaXNzYWJsZTogdHJ1ZX0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGNhdGNoKGVycikge1xyXG4gICAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRFcnJvcihlcnIsIHtkaXNtaXNzYWJsZTogdHJ1ZX0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfSwgMTAwMDApO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIGdyYW1tYXJzIGJlZm9yZSB1cG9kYXRpbmdcclxuICByZW1vdmVHcmFtbWFycygpIHtcclxuICAgIGF0b20uZ3JhbW1hcnMucmVtb3ZlR3JhbW1hckZvclNjb3BlTmFtZSh0aGlzLlRUTFNDT1BFTkFNRSk7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgYWxsIGxhbmd1YWdlIGZpbGVzIGluIHRhZ2dlZCB0ZW1wbGF0ZSBHcmFtbWFyRmlsZXMgYXJyYXlcclxuICByZW1vdmVUdGxMYW5ndWFnZUZpbGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHRsR3JhbW1hckZpbGVzKCkudGhlbiggKHR0bEdyYW1tYXJGaWxlcykgPT4ge1xyXG4gICAgICBmb3IgKGxldCB0dGxHcmFtbWFyRmlsZW5hbWUgb2YgdHRsR3JhbW1hckZpbGVzKSB7XHJcbiAgICAgICAgbGV0IHR0bEdyYW1tYXJGaWxlQWJzb3VsdGUgPSB0aGlzLm1ha2VUdGxHcmFtbWFyRmlsZW5hbWVBYnNvdWx1dGUodHRsR3JhbW1hckZpbGVuYW1lKTtcclxuICAgICAgICBmcy51bmxpbmsodHRsR3JhbW1hckZpbGVBYnNvdWx0ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICB9XHJcbn07XHJcbiJdfQ==